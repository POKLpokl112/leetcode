Two Queue and add all the Pacific border to one queue; Atlantic border to another queue.
Keep a visited matrix for each queue. In the end, add the cell visited by two queue to the result.
BFS: Water flood from ocean to the cell. Since water can only flow from high/equal cell to low cell, add the neighboor cell with height larger or equal to current cell to the queue and mark as visited.
public class Solution {
    int[][]dir = new int[][]{{1,0},{-1,0},{0,1},{0,-1}};
    public List<int[]> pacificAtlantic(int[][] matrix) {
        List<int[]> res = new LinkedList<>();
        if(matrix == null || matrix.length == 0 || matrix[0].length == 0){
            return res;
        }
        int n = matrix.length, m = matrix[0].length;
        //One visited map for each ocean
        boolean[][] pacific = new boolean[n][m];
        boolean[][] atlantic = new boolean[n][m];
        Queue<int[]> pQueue = new LinkedList<>();
        Queue<int[]> aQueue = new LinkedList<>();
        for(int i=0; i<n; i++){ //Vertical border
            pQueue.offer(new int[]{i, 0});
            aQueue.offer(new int[]{i, m-1});
            pacific[i][0] = true;
            atlantic[i][m-1] = true;
        }
        for(int i=0; i<m; i++){ //Horizontal border
            pQueue.offer(new int[]{0, i});
            aQueue.offer(new int[]{n-1, i});
            pacific[0][i] = true;
            atlantic[n-1][i] = true;
        }
        bfs(matrix, pQueue, pacific);
        bfs(matrix, aQueue, atlantic);
        for(int i=0; i<n; i++){
            for(int j=0; j<m; j++){
                if(pacific[i][j] && atlantic[i][j])
                    res.add(new int[]{i,j});
            }
        }
        return res;
    }
    public void bfs(int[][]matrix, Queue<int[]> queue, boolean[][]visited){
        int n = matrix.length, m = matrix[0].length;
        while(!queue.isEmpty()){
            int[] cur = queue.poll();
            for(int[] d:dir){
                int x = cur[0]+d[0];
                int y = cur[1]+d[1];
                if(x<0 || x>=n || y<0 || y>=m || visited[x][y] || matrix[x][y] < matrix[cur[0]][cur[1]]){
                    continue;
                }
                visited[x][y] = true;
                queue.offer(new int[]{x, y});
            } 
        }
    }
}
DFS version:

public class Solution {
    public List<int[]> pacificAtlantic(int[][] matrix) {
        List<int[]> res = new LinkedList<>();
        if(matrix == null || matrix.length == 0 || matrix[0].length == 0){
            return res;
        }
        int n = matrix.length, m = matrix[0].length;
        boolean[][]pacific = new boolean[n][m];
        boolean[][]atlantic = new boolean[n][m];
        for(int i=0; i<n; i++){
            dfs(matrix, pacific, Integer.MIN_VALUE, i, 0);
            dfs(matrix, atlantic, Integer.MIN_VALUE, i, m-1);
        }
        for(int i=0; i<m; i++){
            dfs(matrix, pacific, Integer.MIN_VALUE, 0, i);
            dfs(matrix, atlantic, Integer.MIN_VALUE, n-1, i);
        }
        for (int i = 0; i < n; i++) 
            for (int j = 0; j < m; j++) 
                if (pacific[i][j] && atlantic[i][j]) 
                    res.add(new int[] {i, j});
        return res;
    }
    
    int[][]dir = new int[][]{{0,1},{0,-1},{1,0},{-1,0}};
    
    public void dfs(int[][]matrix, boolean[][]visited, int height, int x, int y){
        int n = matrix.length, m = matrix[0].length;
        if(x<0 || x>=n || y<0 || y>=m || visited[x][y] || matrix[x][y] < height)
            return;
        visited[x][y] = true;
        for(int[]d:dir){
            dfs(matrix, visited, matrix[x][y], x+d[0], y+d[1]);
        }
    }
}

class Solution {
    
    int[][] q = new int[][]{{0,1},{1,0},{-1,0},{0,-1}};
    public List<int[]> pacificAtlantic(int[][] matrix) {
        if(matrix==null||matrix.length==0||matrix[0].length==0){
            return new ArrayList<>();
        }
        
        int n = matrix.length,m=matrix[0].length;
        boolean[][] pp = new boolean[n][m],aa=new boolean[n][m];
        for(int i =0;i<n;i++){
        	qwe(matrix,pp,i,0,Integer.MIN_VALUE);
        	qwe(matrix,aa,i,m-1,Integer.MIN_VALUE);
        }
        
        for(int i=0;i<m;i++){
        	qwe(matrix,pp,0,i,Integer.MIN_VALUE);
        	qwe(matrix,aa,n-1,i,Integer.MIN_VALUE);
        }
        
        List<int[]> list = new ArrayList<>();
        for(int i = 0;i<n;i++){
        	for(int j=0;j<m;j++){
        		if(pp[i][j]&&aa[i][j]){
        			list.add(new int[]{i,j});
        		}
        	}
        }
        
        return list;
    }
    
    public void qwe(int[][] m,boolean[][] ii,int i,int j,int h){
        if(i<0||j<0||i==m.length||j==m[0].length||ii[i][j]||m[i][j]<h){
            return;
        }
        
        ii[i][j]=true;
        
        for(int[] qq:q){
            qwe(m,ii,i+qq[0],j+qq[1],m[i][j]);
        }
    }
}

Given an 2D board, count how many battleships are in it. The battleships are represented with 'X's, empty slots are represented with '.'s. You may assume the following rules:
You receive a valid board, made of only battleships or empty slots.
Battleships can only be placed horizontally or vertically. In other words, they can only be made of the shape 1xN (1 row, N columns) or Nx1 (N rows, 1 column), where N can be of any size.
At least one horizontal or vertical cell separates between two battleships - there are no adjacent battleships.
Example:
X..X
...X
...X
In the above board there are 2 battleships.
Invalid Example:
...X
XXXX
...X
This is an invalid board that you will not receive - as battleships will always have a cell separating between them.
Follow up:
Could you do it in one-pass, using only O(1) extra memory and without modifying the value of the board?

class Solution {
    public int countBattleships(char[][] board) {
        int r =0;
        for(int i =0;i<board.length;i++){
        	for(int j=0;j<board[0].length;j++){
        		if(board[i][j]=='.'||(i>0&&board[i-1][j]=='X')||(j>0&&board[i][j-1]=='X')continue;
        		r++;
        	}
        }
        return r;
    }
}

Going over all cells, we can count only those that are the "first" cell of the battleship. First cell will be defined as the most top-left cell. We can check for first cells by only counting cells that do not have an 'X' to the left and do not have an 'X' above them.


    public int countBattleships(char[][] board) {
        int m = board.length;
        if (m==0) return 0;
        int n = board[0].length;
        
        int count=0;
        
        for (int i=0; i<m; i++) {
            for (int j=0; j<n; j++) {
                if (board[i][j] == '.') continue;
                if (i > 0 && board[i-1][j] == 'X') continue;
                if (j > 0 && board[i][j-1] == 'X') continue;
                count++;
            }
        }
        
        return count;
    }

A password is considered strong if below conditions are all met:

It has at least 6 characters and at most 20 characters.
It must contain at least one lowercase letter, at least one uppercase letter, and at least one digit.
It must NOT contain three repeating characters in a row ("...aaa..." is weak, but "...aa...a..." is strong, assuming other conditions are met).
Write a function strongPasswordChecker(s), that takes a string s as input, and return the MINIMUM change required to make s a strong password. If s is already strong, return 0.

Insertion, deletion or replace of any one character are all considered as one change.

class Solution {
    public int strongPasswordChecker(String s) {
        
         int z = 0;
        int q = 0;
        
        int a = 1;
        int f = 1;
        int d = 1;
        int c = Integer.MAX_VALUE;
        
        int k = 0 ;
        if(s.length()<6){
        	q+=6-s.length();
        	
        }else if(s.length()>20){
        	k=s.length()-20;
        }
        List<Integer> list = new ArrayList<>();
        for(int i =0;i<s.length();i++){
        	if(a==1&&(s.charAt(i)>='a'&&s.charAt(i)<='z')){
        		a=0;
        	}else if(f==1&&(s.charAt(i)>='A'&&s.charAt(i)<='Z')){
        		f=0;
        	}else if(d==1&&(s.charAt(i)>='0'&&s.charAt(i)<='9')){
        		d=0;
        	}
        	
        	if(s.charAt(i)==c){
        		z++;
        	}else{
        		c=s.charAt(i);
        		list.add(z);
        		z=1;
        	}
        }
        
        list.add(z);
        int t = a+f+d;
        int r =0;
        if(q>0){
        	return q>t?q:t;
        }else if(k>0){
        	int b = 0;
        	for(int g :list){
        		b+=g/3;
        	}
        	"1234567890123456Baaaaa"
        	b=1 k =2 t=0
        	"abababababababababaaa"
        	b =1 k =1 t=2
        	return b>k+t?b:k+t+b;
        }else{
        	int b = 0;
        	for(int g :list){
        		b+=g/3;
        	}
        	
        	return b>t?b:t;
        }
        
    }
}

Given a non-empty array of numbers, a0, a1, a2, … , an-1, where 0 ≤ ai < 231.

Find the maximum result of ai XOR aj, where 0 ≤ i, j < n.

Could you do this in O(n) runtime?

Example:

Input: [3, 10, 5, 25, 2, 8]

Output: 28

Explanation: The maximum result is 5 ^ 25 = 28.
 
    
  class T{
  	T[] tt= new T[2];
  }
 class Solution {
    public int findMaximumXOR(int[] nums) {
    
    	if(nums.length()<2)return 0;
    	T t = new T();
    	for(int n: nums){
    		T g = t;
    		for(int i =31;i>-1;i--){
    			int q = (n>>i)&1;
    			if(g.tt[q]==null){
    				g.tt[q]=new T();
    			}
    			g=g.tt[q];
    		}
    	}
    	
    	int r = Integer.MIN_VALUE;
    	for(int n: nums){
    		T g = t;
    		int ss = 0;
    		for(int i =31;i>-1;i--){
    			int q = (n>>i)&1;
    			if(g.tt[~q]!=null){
    				ss+=1<<i;
    				g=g.tt[~q];
    			}else{
    				g=g.tt[q];
    			}
    		}
    		r=Math.max(ss,r);
    	}
    	return r;
}

423. Reconstruct Original Digits from English
Given a non-empty string containing an out-of-order English representation of digits 0-9, output the digits in ascending order.

Note:
Input contains only lowercase English letters.
Input is guaranteed to be valid and can be transformed to its original digits. That means invalid inputs such as "abc" or "zerone" are not permitted.
Input length is less than 50,000.
Example 1:
Input: "owoztneoer"

Output: "012"
Example 2:
Input: "fviefuro"

Output: "45"

class Solution {
    public String originalDigits(String s) {
        int[] counts = new int[26];
        int[] nums = new int[10];
        for(char c : s.toCharArray()){
        	counts[c-'a']++;
        }
        nums[0]=counts['z'-'a'];
         nums[2] = counts['w'-'a'];
        nums[4] = counts['u'-'a'];
        nums[6] = counts['x'-'a'];
        nums[8] = counts['g'-'a'];
        nums[1] = counts['o'-'a'] - nums[0] - nums[2] - nums[4];
        nums[3] = counts['h'-'a'] - nums[8];
        nums[5] = counts['f'-'a'] - nums[4];
        nums[7] = counts['s'-'a'] - nums[6];
        nums[9] = counts['i'-'a'] - nums[6] - nums[8] - nums[5];
        
        String q = "";
        for(int i=0;i<10;i++){
        	if(nums[i]>0){
        		q+=i;
        	}
        }
        
        return q;
    }
}

424. Longest Repeating Character Replacement
Given a string that consists of only uppercase English letters, you can replace any letter in the string with another letter at most k times. Find the length of a longest substring containing all repeating letters you can get after performing the above operations.

Note:
Both the string's length and k will not exceed 104.

Example 1:

Input:
s = "ABAB", k = 2

Output:
4

Explanation:
Replace the two 'A's with two 'B's or vice versa.
Example 2:

Input:
s = "AABABBA", k = 1

Output:
4

Explanation:
Replace the one 'A' in the middle with 'B' and form "AABBBBA".
The substring "BBBB" has the longest repeating letters, which is 4.

class Solution {
    public int characterReplacement(String s, int k) {
    	int[] ss = new int[26];
    	int m =0,q=0,z=0;
        for(int i = 0;i<s.length();i++){
        	m=Math.max(m,++ss[s.charAt(i)-'A'])
        	if(i-q+1-m>k){
        		ss[s.charAt(q)-'A']--;
        		q++;
        	}
        	z=Math.max(z,i-q+1);
        }
        return z;
    }
}

@hollin you may think the maxCount means the upper bound of the 'maxCount' of all the past windows, we may get the wrong length for the current window, but we never miss the result, thinks about this case,k=2:

(0A: 0 is the idx, A is the char)
0A1A2B3C4D5E6F

for window[0A1A2B3C], we get the maxCount=2 for A, and it is still valid, now we move end->4D, we get a invalid window, now the count[A] =1, maxCount is still 2, later we move to end->5E,
the maxCount is still 2, but actually the count for each char in window [2B3C4D5E] is 1, but it does not matter, the maxLength do not update.



public int characterReplacement(String s, int k) {
        int len = s.length();
        int[] count = new int[26];
        int start = 0, maxCount = 0, maxLength = 0;
        for (int end = 0; end < len; end++) {
            maxCount = Math.max(maxCount, ++count[s.charAt(end) - 'A']);
            while (end - start + 1 - maxCount > k) {
                count[s.charAt(start) - 'A']--;
                start++;
            }
            maxLength = Math.max(maxLength, end - start + 1);
        }
        return maxLength;
    }
There's no edge case for this question. The initial step is to extend the window to its limit, that is, the longest we can get to with maximum number of modifications. Until then the variable start will remain at 0.

Then as end increase, the whole substring from 0 to end will violate the rule, so we need to update start accordingly (slide the window). We move start to the right until the whole string satisfy the constraint again. Then each time we reach such situation, we update our max length.

/*
// Definition for a Node.
class Node {
    public int val;
    public List<Node> children;

    public Node() {}

    public Node(int _val,List<Node> _children) {
        val = _val;
        children = _children;
    }
};
*/
class Solution {
    public List<List<Integer>> levelOrder(Node root) {
        List<List<Integer>> list = new ArrayList<>();
        qwe(root,0,list);
        return list;
        
        
        
    }
    
    public void qwe(Node root,int i,List<List<Integer>> list){
    	while(list.size()<i){
    		list.add(new ArrayList<>());
    	}
    	
    	List<Integer> array = list.get(i-1);
    	array.add(root.val);
    	if(root.children!=null){
    		for(Node r:root.children){
    			qwe(r,i+1,list);
    		}
    	}
    }
}

430. Flatten a Multilevel Doubly Linked List
Medium

311

52

Favorite

Share
You are given a doubly linked list which in addition to the next and previous pointers, it could have a child pointer, which may or may not point to a separate doubly linked list. These child lists may have one or more children of their own, and so on, to produce a multilevel data structure, as shown in the example below.

Flatten the list so that all the nodes appear in a single-level, doubly linked list. You are given the head of the first level of the list.

 /*
// Definition for a Node.
class Node {
    public int val;
    public Node prev;
    public Node next;
    public Node child;

    public Node() {}

    public Node(int _val,Node _prev,Node _next,Node _child) {
        val = _val;
        prev = _prev;
        next = _next;
        child = _child;
    }
};
*/
class Solution {
    public Node flatten(Node head) {
        if(head==null)return null;
        Node p = head.prev;
        Node n = head.next;
        Node c = head.child;
        if(c!=null){
        	c=flatten(c);
        	head.next=c;
        	c.prev=head;
        	while(c.next!=null){
	        	c=c.next;
	        }
	        c.next=n;
	        head.child=null;
        }
       
        if(n!=null){
        	if(c!=null)
        	n.prev=c;
        	n=flatten(n);
        }
        
        return head;
    }
}

Construct Quad Tree
We want to use quad trees to store an N x N boolean grid. Each cell in the grid can only be true or false. The root node represents the whole grid. For each node, it will be subdivided into four children nodes until the values in the region it represents are all the same.

Each node has another two boolean attributes : isLeaf and val. isLeaf is true if and only if the node is a leaf node. The val attribute for a leaf node contains the value of the region it represents.

Your task is to use a quad tree to represent a given grid. The following example may help you understand the problem better:

Given the 8 x 8 grid below, we want to construct the corresponding quad tree:



It can be divided according to the definition above:



 

The corresponding quad tree should be as following, where each node is represented as a (isLeaf, val) pair.

For the non-leaf nodes, val can be arbitrary, so it is represented as *.



Note:

N is less than 1000 and guaranteened to be a power of 2.
If you want to know more about the quad tree, you can refer to its wiki.

/*
// Definition for a QuadTree node.
class Node {
    public boolean val;
    public boolean isLeaf;
    public Node topLeft;
    public Node topRight;
    public Node bottomLeft;
    public Node bottomRight;

    public Node() {}

    public Node(boolean _val,boolean _isLeaf,Node _topLeft,Node _topRight,Node _bottomLeft,Node _bottomRight) {
        val = _val;
        isLeaf = _isLeaf;
        topLeft = _topLeft;
        topRight = _topRight;
        bottomLeft = _bottomLeft;
        bottomRight = _bottomRight;
    }
};
*/
class Solution {
    public Node construct(int[][] grid) {
       return qwe(grid,0,0,grid.length);
    }
    
    public Node qwe(int[][] ii,int s,int e,int l){
    	for(int i = s;i<s+l;i++){
    		for(int j =e;j<e+l;j++){
    			if(ii[i][j]!=ii[s][e]){
    				return new Node(true,false,
    				qwe(ii,s,e,l/2),
    				qwe(ii,s,e+l/2,l/2),
    				qwe(ii,s+l/2,e,l/2),
    				qwe(ii,s+l/2,e+l/2,l/2));
    			}
    		}
    	}
    	
    	return return new Node(ii[s][e]==1,true,null,null,null,null);
    }
}

All O`one Data Structure
Hard
Implement a data structure supporting the following operations:

Inc(Key) - Inserts a new key with value 1. Or increments an existing key by 1. Key is guaranteed to be a non-empty string.
Dec(Key) - If Key's value is 1, remove it from the data structure. Otherwise decrements an existing key by 1. If the key does not exist, this function does nothing. Key is guaranteed to be a non-empty string.
GetMaxKey() - Returns one of the keys with maximal value. If no element exists, return an empty string "".
GetMinKey() - Returns one of the keys with minimal value. If no element exists, return an empty string "".
Challenge: Perform all these in O(1) time complexity.

class AllOne {

	Map<String,Integer> map = new HashMap<>();
    /** Initialize your data structure here. */
    public AllOne() {
        
    }
    
    /** Inserts a new key <Key> with value 1. Or increments an existing key by 1. */
    public void inc(String key) {
        Integer z = map.get(key);
        if(z==null){
        	z=0;
        }
        map.put(key,z+1);
    }
    ["AllOne","inc","inc","inc","inc","inc","inc","dec", "dec","getMinKey","dec","getMaxKey","getMinKey"]
[[],["a"],["b"],["b"],["c"],["c"],["c"],["b"],["b"],[],["a"],[],[]]
    /** Decrements an existing key by 1. If Key's value is 1, remove it from the data structure. */
    public void dec(String key) {
        Integer z = map.get(key);
        if(z==null)return;
        if(z==1){
        	map.remove(key);
        }
        map.put(key,z-1);
    }
    
    /** Returns one of the keys with maximal value. */
    public String getMaxKey() {
       	String s = "";
       	Integer x = Integer.MIN_VALUE;
       	for(Map.Entry<String,Integer> entry : map.entrySet()){
       		if(x<entry.getValue()){
       			x=entry.getValue();
       			s=entry.getKey();
       		}
       		
       	}
        return s;
    }
    
    /** Returns one of the keys with Minimal value. */
    public String getMinKey() {
        String s = "";
       	Integer x = Integer.MAX_VALUE;
       	for(Map.Entry<String,Integer> entry : map.entrySet()){
       		if(x>entry.getValue()){
       			x=entry.getValue();
       			s=entry.getKey();
       		}
       		
       	}
        return s;
    }
}

/**
 * Your AllOne object will be instantiated and called as such:
 * AllOne obj = new AllOne();
 * obj.inc(key);
 * obj.dec(key);
 * String param_3 = obj.getMaxKey();
 * String param_4 = obj.getMinKey();
 */
 
 433. Minimum Genetic Mutation
Medium
A gene string can be represented by an 8-character long string, with choices from "A", "C", "G", "T".

Suppose we need to investigate about a mutation (mutation from "start" to "end"), where ONE mutation is defined as ONE single character changed in the gene string.

For example, "AACCGGTT" -> "AACCGGTA" is 1 mutation.

Also, there is a given gene "bank", which records all the valid gene mutations. A gene must be in the bank to make it a valid gene string.

Now, given 3 things - start, end, bank, your task is to determine what is the minimum number of mutations needed to mutate from "start" to "end". If there is no such a mutation, return -1.

Note:

Starting point is assumed to be valid, so it might not be included in the bank.
If multiple mutations are needed, all mutations during in the sequence must be valid.
You may assume start and end string is not the same.
 

Example 1:

start: "AACCGGTT"
end:   "AACCGGTA"
bank: ["AACCGGTA"]

return: 1
 

Example 2:

start: "AACCGGTT"
end:   "AAACGGTA"
bank: ["AACCGGTA", "AACCGCTA", "AAACGGTA"]

return: 2
 

Example 3:

start: "AAAAACCC"
end:   "AACCCCCC"
bank: ["AAAACCCC", "AAACCCCC", "AACCCCCC"]

return: 3

class Solution {
	
    public int minMutation(String start, String end, String[] bank) {
    	int m = asd(start,end);
    	
    	Map<Integer,List<String>> map = new HashMap<>();
    	for(String s : bank){
    		int i = asd(s,start);
	    	List<String> list = map.get(i);
	    	if(list==null){
	    		list = new ArrayList<>();
	    		map.put(i,list);
	    	}
	    	list.add(s);
    	}
    	
    	return qwe(start,end,map,1,new ArrayList<>());
    }
    
    public int asd(String q,String w){
    	int i = 0;
    	for(int j=0;j<8;j++){
    		if(q.charAt(j)!=w.charAt(j)){
        		i++;
    		}
    	}
    	return i;
    }
    
    public int qwe(String start,String end,Map<Integer,List<String>> map,int c,List<String> qwe){
    	if(start.equals(end))return 0;
    	List<String> list = map.get(c);
    	if(list==null){
    		return -1;
    	}
    	
    	int x=Integer.MAX_VALUE;
    	for(String s : list){
    		if(qwe.contains(s)){
    			continue;
    		}
    		int i = asd(s,start);
    		if(i==1){
    			List<String> asd = new ArrayList<>(qwe);
    			asd.add(s);
    			int z = qwe(s,end,map,c+1,asd);
    			int zz = qwe(s,end,map,c-1,asd);
    			int zzz =z!=-1?(zz==-1?z:(z>zz?zz:z)):(zz==-1?-1:z);
    			if(zzz!=-1)x=Math.min(zzz+1,x);
    		}
    	}
    	
    	return x!=Integer.MAX_VALUE?x:-1;
    }
    
}

434. Number of Segments in a String
Easy
Count the number of segments in a string, where a segment is defined to be a contiguous sequence of non-space characters.

Please note that the string does not contain any non-printable characters.

Example:

Input: "Hello, my name is John"
Output: 5

class Solution {
    public int countSegments(String s) {
        int q= 0;
        boolean b = false;
        for(int i =0;i<s.length();i++){
        	if(s.charAt(i)==' '){
        		b=false;
        	}else{
        		if(!b)q++;
        		b=true;
        	}
        }
        return q;
    }
}


435. Non-overlapping Intervals
Medium
Given a collection of intervals, find the minimum number of intervals you need to remove to make the rest of the intervals non-overlapping.

Note:

You may assume the interval's end point is always bigger than its start point.
Intervals like [1,2] and [2,3] have borders "touching" but they don't overlap each other.
 

Example 1:

Input: [ [1,2], [2,3], [3,4], [1,3] ]

Output: 1

Explanation: [1,3] can be removed and the rest of intervals are non-overlapping.
 

Example 2:

Input: [ [1,2], [1,2], [1,2] ]

Output: 2

Explanation: You need to remove two [1,2] to make the rest of intervals non-overlapping.
 

Example 3:

Input: [ [1,2], [2,3] ]

Output: 0

Explanation: You don't need to remove any of the intervals since they're already non-overlapping.
NOTE: input types have been changed on April 15, 2019. Please reset to default code definition to get new method signature.

class Solution {
    public int eraseOverlapIntervals(int[][] intervals) {
    	if(intervals.length==0)return 0;
    	Arrays.sort(intervals,new Comparetor<int[][]>(){
    		@Override
    		public int compare(int[][] i1,int[][] i2){
    			return i1[1]-i2[1];
    		}
    	})
    	
    	int max = 0;
    	int e = intervals[0][1];
    	for(int i =1;i<intervals.length;i++){
    		if(e<=intervals[i][0]){
    			e=intervals[i][1];
    			max++;
    		}
    	}
    	
    	return intervals.length-max;
    }
    
    public int qwe(int[][] qq){
    	if(qq.length<1)return 0;
    	List<Integer>[] ll = new List[qq.length];
    	int max =0;
    	int m= 0 ;
    	List<int[]> qwe = new ArrayList<>();
    	for(int[] ii : qq){
    		boolean b =true;
    		for(int[] jj:qwe){
    			if(ii[0]==jj[0]&&ii[1]==jj[1]){
    				b=false;
    				max++;
    				break;
    			}
    		}
    		if(b){
    			qwe.add(ii);
    		}
    	}
    	for(int i = 0;i<qwe.size()-1;i++){
    		for(int j=i+1;j<qwe.size();j++){
    			if((qwe.get(i)[1]>qwe.get(j)[0]&&qwe.get(i)[1]<=qwe.get(j)[1])||(qwe.get(i)[0]<qwe.get(j)[1]&&qwe.get(i)[0]>=qwe.get(j)[0])){
    				if(ll[i]==null){
    					ll[i]=new ArrayList<>();
    				}
    				ll[i].add(j);
    				if(ll[j]==null){
    					ll[j]=new ArrayList<>();
    				}
    				ll[j].add(i);
    				m=Math.max(Math.max(ll[j].size(),ll[i].size()),m);
    			}
    		}
    	}
    	while(m!=0){
    		for(int j=0;j<ll.length;j++){
    			if(ll[j]!=null&&ll[j].size()==m){
    				for(int i:ll[j]){
    					ll[i].remove(Integer.valueOf(j));
    				}
    				ll[j]=null;
    				max++;
    			}
    		}
    		m--;
    	}
    	return max;
    }
    [[0,2],[1,3],[1,3],[2,4],[3,5],[3,5],[4,6]]
}

Actually, the problem is the same as "Given a collection of intervals, find the maximum number of intervals that are non-overlapping." (the classic Greedy problem: Interval Scheduling). With the solution to that problem, guess how do we get the minimum number of intervals to remove? : )

Sorting Interval.end in ascending order is O(nlogn), then traverse intervals array to get the maximum number of non-overlapping intervals is O(n). Total is O(nlogn).

    public int eraseOverlapIntervals(Interval[] intervals) {
        if (intervals.length == 0)  return 0;

        Arrays.sort(intervals, new myComparator());
        int end = intervals[0].end;
        int count = 1;        

        for (int i = 1; i < intervals.length; i++) {
            if (intervals[i].start >= end) {
                end = intervals[i].end;
                count++;
            }
        }
        return intervals.length - count;
    }
    
    class myComparator implements Comparator<Interval> {
        public int compare(Interval a, Interval b) {
            return a.end - b.end;
        }
    }

436. Find Right Interval
Given a set of intervals, for each of the interval i, check if there exists an interval j whose start point is bigger than or equal to the end point of the interval i, which can be called that j is on the "right" of i.

For any interval i, you need to store the minimum interval j's index, which means that the interval j has the minimum start point to build the "right" relationship for interval i. If the interval j doesn't exist, store -1 for the interval i. Finally, you need output the stored value of each interval as an array.

Note:

You may assume the interval's end point is always bigger than its start point.
You may assume none of these intervals have the same start point.
 

Example 1:

Input: [ [1,2] ]

Output: [-1]

Explanation: There is only one interval in the collection, so it outputs -1.
 

Example 2:

Input: [ [3,4], [2,3], [1,2] ]

Output: [-1, 0, 1]

Explanation: There is no satisfied "right" interval for [3,4].
For [2,3], the interval [3,4] has minimum-"right" start point;
For [1,2], the interval [2,3] has minimum-"right" start point.
 

Example 3:

Input: [ [1,4], [2,3], [3,4] ]

Output: [-1, 2, -1]

Explanation: There is no satisfied "right" interval for [1,4] and [3,4].
For [2,3], the interval [3,4] has minimum-"right" start point.
NOTE: input types have been changed on April 15, 2019. Please reset to default code definition to get new method signature.

437. Path Sum III
You are given a binary tree in which each node contains an integer value.

Find the number of paths that sum to a given value.

The path does not need to start or end at the root or a leaf, but it must go downwards (traveling only from parent nodes to child nodes).

The tree has no more than 1,000 nodes and the values are in the range -1,000,000 to 1,000,000.

Example:

root = [10,5,-3,3,2,null,11,3,-2,null,1], sum = 8

      10
     /  \
    5   -3
   / \    \
  3   2   11
 / \   \
3  -2   1

Return 3. The paths that sum to 8 are:

1.  5 -> 3
2.  5 -> 2 -> 1
3. -3 -> 11

class Solution {
    public int pathSum(TreeNode root, int sum) {
      if(root==null)return 0;
      int l = pathSum(root.left,sum);
      int r = pathSum(root.right,sum);
      int j = qwe(root.left,sum-root.val);
      int i = qwe(root.right,sum-root.val);
	  if(root.val==sum)return i+j+l+r+1;
	  return l+r;      
    }
    [1,-2,-3,1,3,-2,null,-1]
	-1
    public int qwe(TreeNode root,int sum){
    	if(root==null)return 0;
    	int l = qwe(root.left,sum-root.val);
      	int r = qwe(root.right,sum-root.val);
      	if(root.val==sum)return l+r+1;
	  	return l+r;      
    }
    public int qwe(TreeNode root, int sum){
    	
    }
    public int qwe(TreeNode root, int sum,boolean b){
    	if(root==null)return 0;
        int i=0,j=0,g=0,k=0,l=0;
        if(b){
	        i = qwe(root.left,sum,b);
	        j = qwe(root.right,sum,b);
        }
        if(root.val==sum)g=1;
        else{
         k = qwe(root.left,sum-root.val,false);
         l = qwe(root.right,sum-root.val,false);
        }
        return i+j+k+l+g;
    }
    
    [1,-2,-3,1,3,-2,null,-1]
	1
	[1,-2,-3,1,3,-2,null,-1]
	-1
}

438. Find All Anagrams in a String
Given a string s and a non-empty string p, find all the start indices of p's anagrams in s.

Strings consists of lowercase English letters only and the length of both strings s and p will not be larger than 20,100.

The order of output does not matter.

Example 1:

Input:
s: "cbaebabacd" p: "abc"

Output:
[0, 6]

Explanation:
The substring with start index = 0 is "cba", which is an anagram of "abc".
The substring with start index = 6 is "bac", which is an anagram of "abc".
Example 2:

Input:
s: "abab" p: "ab"

Output:
[0, 1, 2]

Explanation:
The substring with start index = 0 is "ab", which is an anagram of "ab".
The substring with start index = 1 is "ba", which is an anagram of "ab".
The substring with start index = 2 is "ab", which is an anagram of "ab".

class Solution {
    public List<Integer> findAnagrams(String s, String p) {
    	if(s.length()<p.length())return new ArrayList<>();
    	List<Integer> list = new ArrayList<>();
    	
    	int[] i1 = new int[26];
    	int[] ii = new int[26];
    	
    	for(int i = 0;i<p.length();i++){
    		char c = p.charAt(i);
			i1[c-'a']++;
			
    		char cc = s.charAt(i);
    		ii[cc-'a']++;
    	}
    	
    	if(c(i1,ii))list.add(0);
    	for(int i =0 ;i<s.length()-p.length();i++){
    		char c = s.charAt(p.length()+i);
    		ii[c-'a']++;
    		char cc = s.charAt(i);
    		ii[cc-'a']--;
    		if(i1[c-'a']>0&&c(i1,ii)){
    			list.add(i+1);
    		}
    	}
    	
    	return list;
    }
    
    public boolean c(int[] i1,int[] ii){
    	for(int i =0;i<26;i++){
    		if(i1[i]!=ii[i])return false;
    	}
    	return true;
    }
    
    "cbaebabacd"
	"abc"
    public boolean check(Map<Character,Integer> map,Map<Character,Integer> m){
    	for(Map.Entry<Character,Integer> entry : map.entrySet()){
    		Integer i = m.get(entry.getKey());
    		if(i==null||i.intValue()!=entry.getValue()){
    			return false;
    		}
    	}
    	return true;
    }
}

K-th Smallest in Lexicographical Order
Hard

Share
Given integers n and k, find the lexicographically k-th smallest integer in the range from 1 to n.

Note: 1 ≤ k ≤ n ≤ 109.

Example:

Input:
n: 13   k: 2

Output:
10

Explanation:
The lexicographical order is [1, 10, 11, 12, 13, 2, 3, 4, 5, 6, 7, 8, 9], so the second smallest number is 10.
Initially, image you are at node 1 (variable: curr),
the goal is move (k - 1) steps to the target node x. (substract steps from k after moving)
when k is down to 0, curr will be finally at node x, there you get the result.

we don't really need to do a exact k steps preorder traverse of the denary tree, the idea is to calculate the steps between curr and curr + 1 (neighbor nodes in same level), in order to skip some unnecessary moves.

Main function
Firstly, calculate how many steps curr need to move to curr + 1.

if the steps <= k, we know we can move to curr + 1, and narrow down k to k - steps.

else if the steps > k, that means the curr + 1 is actually behind the target node x in the preorder path, we can't jump to curr + 1. What we have to do is to move forward only 1 step (curr * 10 is always next preorder node) and repeat the iteration.

calSteps function

how to calculate the steps between curr and curr + 1?
Here we come up a idea to calculate by level.
Let n1 = curr, n2 = curr + 1.
n2 is always the next right node beside n1's right most node (who shares the same ancestor "curr")
(refer to the pic, 2 is right next to 1, 20 is right next to 19, 200 is right next to 199).

so, if n2 <= n, what means n1's right most node exists, we can simply add the number of nodes from n1 to n2 to steps.

else if n2 > n, what means n (the biggest node) is on the path between n1 to n2, add (n + 1 - n1) to steps.

organize this flow to "steps += Math.min(n + 1, n2) - n1; n1 *= 10; n2 *= 10;"

Here is the code snippet:

public int findKthNumber(int n, int k) {
    int curr = 1;
    k = k - 1;
    while (k > 0) {
        int steps = calSteps(n, curr, curr + 1);
        if (steps <= k) {
            curr += 1;
            k -= steps;
        } else {
            curr *= 10;
            k -= 1;
        }
    }
    return curr;
}
//use long in case of overflow
public int calSteps(int n, long n1, long n2) {
    int steps = 0;
    while (n1 <= n) {
        steps += Math.min(n + 1, n2) - n1;
        n1 *= 10;
        n2 *= 10;
    }
    return steps;
}

class Solution {
    public int findKthNumber(int n, int k) {
    	int c = 1;
    	k--;
     	while(k>0){
     		int q = (qwe(n,c,c+1);
     		if(q<=k){
     			c++;
     			k-=q;
     		}else{
     			c*=10;
     			k--;
     		}
     	}
     	return c;
    	
    }
    
   public int qwe(int n,long a ,long b){
   		int q = 0;
   		while(a<=n){
   			q+=Math.min(n+1,b)-a;
   			b*=10;
   			a*=10;
   		}
   		return q;
   }
}

441. Arranging Coins
You have a total of n coins that you want to form in a staircase shape, where every k-th row must have exactly k coins.

Given n, find the total number of full staircase rows that can be formed.

n is a non-negative integer and fits within the range of a 32-bit signed integer.

Example 1:

n = 5

The coins can form the following rows:
¤
¤ ¤
¤ ¤

Because the 3rd row is incomplete, we return 2.
Example 2:

n = 8

The coins can form the following rows:
¤
¤ ¤
¤ ¤ ¤
¤ ¤

Because the 4th row is incomplete, we return 3.

JAVA] Clean Code with Explanations and Running Time [2 Solutions]
Full Solutions and Explanations
Solution 1
``` public class Solution { public int arrangeCoins(int n) { int start = 0; int end = n; int mid = 0; while (start >> 1; if ((0.5 * mid * mid + 0.5 * mid )
Complexity Analysis
Uniform cost model is used as Cost Model and `n` is the input number. `b` in this case would be `2`.

Time Complexity:

Best Case `O(log_b(n))` : With respect to the input, the algorithm will always depend on the value of input.
Average Case `O(log_b(n))` : With respect to the input, the algorithm will always depend on the value of input.
Worst Case `O(log_b(n))` : With respect to the input, the algorithm will always depend on the value of input.
Auxiliary Space:

Worst Case `O(1)` : Additional variables are of constant size.
Algorithm
Approach: Binary Search

The problem is basically asking the maximum length of consecutive number that has the running sum lesser or equal to `n`. In other word, find `x` that satisfy the following condition:

`1 + 2 + 3 + 4 + 5 + 6 + 7 + ... + x <= n`
`sum_{i=1}^x i <= n`
Running sum can be simplified,

`(x * ( x + 1)) / 2 <= n`
Binary search is used in this case to slowly narrow down the `x` that will satisfy the equation. Note that 0.5 * mid * mid + 0.5 * mid does not have overflow issue as the intermediate result is implicitly autoboxed to double data type.

Solution 2
``` public class Solution { public int arrangeCoins(int n) { return (int) ((Math.sqrt(1 + 8.0 * n) - 1) / 2); } } ```
Complexity Analysis
Uniform cost model is used as Cost Model and `n` is the input number. `b` in this case would be `2`.

Time Complexity:

Best Case `O(1)` : With respect to the input, the algorithm will always perform basic mathematical operation that run in constant time.
Average Case `O(1)` : With respect to the input, the algorithm will always perform basic mathematical operation that run in constant time.
Worst Case `O(1)` : With respect to the input, the algorithm will always perform basic mathematical operation that run in constant time.
Auxiliary Space:

Worst Case `O(1)` : No extra space is used.
Algorithm
Approach: Mathematics

The problem is basically asking the maximum length of consecutive number that has the running sum lesser or equal to `n`. In other word, find `x` that satisfy the following condition:

`1 + 2 + 3 + 4 + 5 + 6 + 7 + ... + x <= n`
`sum_{i=1}^x i <= n`
Running sum can be simplified,

`(x * ( x + 1)) / 2 <= n`
Using quadratic formula, `x` is evaluated to be,

`x = 1 / 2 * (-sqrt(8 * n + 1)-1)` (Inapplicable) or `x = 1 / 2 * (sqrt(8 * n + 1)-1)`
Negative root is ignored and positive root is used instead. Note that 8.0 * n is very important because it will cause Java to implicitly autoboxed the intermediate result into double data type. The code will not work if it is simply 8 * n. Alternatively, an explicit casting can be done 8 * (long) n).

class Solution {
    public int arrangeCoins(int n) {
    	int i =1;
    	while(true){
    		if(n==i){
    			return i;
    		}
    		
    		if(n<i){
    			return i-1;
    		}
    		
    		n-=i;
    		i++;
    	}
    	int q= n;
    	for(int i = 0 ;i<n;i++){
    		if(q==i){
    			return i;
    		}
    		
    		if(q<i){
    			return q-i;
    		}
    		
    		return 
    	}
        
    }
}

442. Find All Duplicates in an Array
Medium
1090
114
Given an array of integers, 1 ≤ a[i] ≤ n (n = size of array), some elements appear twice and others appear once.

Find all the elements that appear twice in this array.

Could you do it without extra space and in O(n) runtime?

Example:
Input:
[4,3,2,7,8,2,3,1]

Output:
[2,3]

class Solution {
    public List<Integer> findDuplicates(int[] nums) {
        List<Integer> list = new ArrayList<>();
        for(int i = 0;i<nums.length;i++){
        	if(nums[i]==i+1){
        		continue;
        	}
        	
        	if(nums[nums[i]-1]==nums[i]){
        		list.add(nums[i]);
        		nums[i]=0;
        		continue;
        	}
        	
        	int t=nums[nums[i]-1];
        	nums[nums[i]-1]=nums[i];
        	nums[i]=t;
        	if(t!=0){
        		i--;
        	}
        	
        }
        
        return list;
    }
}

443. String Compression
Easy
Given an array of characters, compress it in-place.

The length after compression must always be smaller than or equal to the original array.

Every element of the array should be a character (not int) of length 1.

After you are done modifying the input array in-place, return the new length of the array.

 
Follow up:
Could you solve it using only O(1) extra space?

 
Example 1:

Input:
["a","a","b","b","c","c","c"]

Output:
Return 6, and the first 6 characters of the input array should be: ["a","2","b","2","c","3"]

Explanation:
"aa" is replaced by "a2". "bb" is replaced by "b2". "ccc" is replaced by "c3".
 

Example 2:

Input:
["a"]

Output:
Return 1, and the first 1 characters of the input array should be: ["a"]

Explanation:
Nothing is replaced.
 

Example 3:

Input:
["a","b","b","b","b","b","b","b","b","b","b","b","b"]

Output:
Return 4, and the first 4 characters of the input array should be: ["a","b","1","2"].

Explanation:
Since the character "a" does not repeat, it is not compressed. "bbbbbbbbbbbb" is replaced by "b12".
Notice each digit has it's own entry in the array.
 

Note:

All characters have an ASCII value in [35, 126].
1 <= len(chars) <= 1000.
class Solution {
    public int compress(char[] chars) {
        int j = 0;
        int k = 1;
        for(int i = 1;i<chars.length;i++){
         if(chars[j]!=chars[i]||i==chars.length-1){
         	if(k==1){
         		j++;
         	}else{
         		String s = Integer.toString(k);
         		for(int z = 0;z<s.length();z++){
         			chars[++j]=s.charAt(z);
         		}
         		j++;
         	}
         	chars[j]=chars[i];
             k=1;
         }else{
         	k++;
         }
        }
        return j;
    }
    
    int anchor = 0, write = 0;
        for (int read = 0; read < chars.length; read++) {
            if (read + 1 == chars.length || chars[read + 1] != chars[read]) {
                chars[write++] = chars[anchor];
                if (read > anchor) {
                    for (char c: ("" + (read - anchor + 1)).toCharArray()) {
                        chars[write++] = c;
                    }
                }
                anchor = read + 1;
            }
        }
        return write;
}

445. Add Two Numbers II
Medium
737
98
You are given two non-empty linked lists representing two non-negative integers. The most significant digit comes first and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.

You may assume the two numbers do not contain any leading zero, except the number 0 itself.

Follow up:
What if you cannot modify the input lists? In other words, reversing the lists is not allowed.

Example:

Input: (7 -> 2 -> 4 -> 3) + (5 -> 6 -> 4)
Output: 7 -> 8 -> 0 -> 7

/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
    	Stack<ListNode> s = new Stack<>();
    	Stack<ListNode> s2 = new Stack<>();
    	while(l1!=null){
    		s.push(l1);
    		l1=l1.next;
    	}
    	
    	while(l2!=null){
    		s2.push(l2);
    		l2=l2.next;
    	}
    	
    	int i = 0;
    	while(!s.isEmpty()&&!s2.isEmpty()){
    		l1=s.pop();
    		l2=s2.pop();
			i = l1.val+l2.val+i;    		
			l1.val=i%10;
			i/=10;
    	}
    	
    	if(s.isEmpty()){
    		s=s2;
    	}
    	
    	while(!s.isEmpty()){
    		ListNode l = s.pop();
    		l.next = l1;
    		l1=l;
    		i+=l.val;
    		l.val=i%10;
			i/=10;
    	}
    	
    	if(i>0){
    		ListNode ll = new ListNode(i);
    		ll.next=l1;
    		l1=ll;
    	}
    	
    	return l1;
    	
    }
    
    Input:
[3,9,9,9,9,9,9,9,9,9]
[7]
Output:
[-2,-9,-4,-9,-6,-7,-2,-9,0]
Expected:
[4,0,0,0,0,0,0,0,0,6]
    
}

446. Arithmetic Slices II - Subsequence
Hard
267
40
A sequence of numbers is called arithmetic if it consists of at least three elements and if the difference between any two consecutive elements is the same.

For example, these are arithmetic sequences:

1, 3, 5, 7, 9
7, 7, 7, 7
3, -1, -5, -9
The following sequence is not arithmetic.

1, 1, 2, 5, 7
 
A zero-indexed array A consisting of N numbers is given. A subsequence slice of that array is any sequence of integers (P0, P1, ..., Pk) such that 0 ≤ P0 < P1 < ... < Pk < N.

A subsequence slice (P0, P1, ..., Pk) of array A is called arithmetic if the sequence A[P0], A[P1], ..., A[Pk-1], A[Pk] is arithmetic. In particular, this means that k ≥ 2.

The function should return the number of arithmetic subsequence slices in the array A.

The input contains N integers. Every integer is in the range of -231 and 231-1 and 0 ≤ N ≤ 1000. The output is guaranteed to be less than 231-1.

 
Example:

Input: [2, 4, 6, 8, 10]

Output: 7

Explanation:
All arithmetic subsequence slices are:
[2,4,6]
[4,6,8]
[6,8,10]
[2,4,6,8]
[4,6,8,10]
[2,4,6,8,10]
[2,6,10]

At first glance of the problem description, I had a strong feeling that the solution to the original problem can be built through its subproblems, i.e., the total number of arithmetic subsequence slices of the whole input array can be constructed from those of the subarrays of the input array. While I was on the right track to the final solution, it's not so easy to figure out the relations between the original problem and its subproblems.

To begin with, let's be ambitious and reformulate our problem as follows: let T(i) denote the total number of arithmetic subsequence slices that can be formed within subarray A[0, i], where A is the input array and 0 <= i < n with n = A.length. Then our original problem will be T(n - 1), and the base case is T(0) = 0.

To make the above idea work, we need to relate T(i) to all T(j) with 0 <= j < i. Let's take some specific j as an example. If we want to incorporate element A[i] into the subarray A[0, j], what information do we need? As far as I can see, we need to know at least the total number of arithmetic subsequence slices ending at each index k with difference d where 0 <= k <= j and d = A[i] - A[k], (i.e., for each such slice, its last element is A[k] and the difference between every two consecutive elements is d), so that adding A[i] to the end of each such slice will make a new arithmetic subsequence slice.

However, our original formulation of T(i) says nothing about the the total number of arithmetic subsequence slices ending at some particular index and with some particular difference. This renders it impossible to relate T(i) to all T(j). As a rule of thumb, when there is difficulty relating original problem to its subproblems, it usually indicates something goes wrong with your formulation for the original problem.

From our analyses above, each intermediate solution should at least contain information about the total number of arithmetic subsequence slices ending at some particular index with some particular difference. So let's go along this line and reformulate our problem as T(i, d), which denotes the total number of arithmetic subsequence slices ending at index i with difference d. The base case and recurrence relation are as follows:

Base case: T(0, d) = 0 (This is true for any d).
Recurrence relation: T(i, d) = summation of (1 + T(j, d)) as long as 0 <= j < i && d == A[i] - A[j].
For the recurrence relation, it's straightforward to understand the T(j, d) part: for each slice ending at index j with difference d == A[i] - A[j], adding A[i] to the end of the slice will make a new arithmetic subsequence slice, therefore the total number of such new slices will be the same as T(j, d). What you are probably wondering is: where does the 1 come from?

The point here is that to make our recurrence relation work properly, the meaning of arithmetic subsequence slice has to be extended to include slices with only two elements (of course we will make sure these "phony" slices won't contribute to our final count). This is because for each slice, we are adding A[i] to its end to form a new one. If the original slice is of length two, after adding we will have a valid arithmetic subsequence slice with three elements. Our T(i, d) will include all these "generalized" slices. And for each pair of elements (A[j], A[i]), they will form one such "generalized" slice (with only two elements) and thus contribute to one count of T(i, d).

Before jumping to the solution below, I'd like to point out that there are actually overlapping among our subproblems (for example, both T(i, d) and T(i + 1, d) require knowledge of T(j, d) with 0 <= j < i). This necessitates memorization of the intermediate results. Each intermediate result is characterized by two integers: i and d. The former is bounded (i.e., 0 <= i < n) since they are the indices of the element in the input array while the latter is not as d is the difference of two elements in the input array and can be any value. For bounded integers, we can use them to index arrays (or lists) while for unbounded ones, use of HashMap would be more appropriate. So we end up with an array of the same length as the input and whose element type is HashMap.

Here is the Java program (with a quick explanation given at the end). Both time and space complexities are O(n^2). Some minor points for improving the time and space performance are:

Define the type of the difference as Integer type instead of Long. This is because there is no valid arithmetic subsequence slice that can have difference out of the Integer value range. But we do need a long integer to filter out those invalid cases.
Preallocate the HashMap to avoid reallocation to deal with extreme cases.
Refrain from using lambda expressions inside loops.
public int numberOfArithmeticSlices(int[] A) {
    int res = 0;
    Map<Integer, Integer>[] map = new Map[A.length];
		
    for (int i = 0; i < A.length; i++) {
        map[i] = new HashMap<>(i);
        	
        for (int j = 0; j < i; j++) {
            long diff = (long)A[i] - A[j];
            if (diff <= Integer.MIN_VALUE || diff > Integer.MAX_VALUE) continue;
        		
            int d = (int)diff;
            int c1 = map[i].getOrDefault(d, 0);
            int c2 = map[j].getOrDefault(d, 0);
            res += c2;
            map[i].put(d, c1 + c2 + 1);
        }
    }
		
    return res;
}
Quick explanation:

res is the final count of all valid arithmetic subsequence slices; map will store the intermediate results T(i, d), with i indexed into the array and d as the key of the corresponding HashMap.
For each index i, we find the total number of "generalized" arithmetic subsequence slices ending at it with all possible differences. This is done by attaching A[i] to all slices of T(j, d) with j less than i.
Within the inner loop, we first use a long variable diff to filter out invalid cases, then get the counts of all valid slices (with element >= 3) as c2 and add it to the final count. At last we update the count of all "generalized" slices for T(i, d) by adding the three parts together: the original value of T(i, d), which is c1 here, the counts from T(j, d), which is c2 and lastly the 1 count of the "two-element" slice (A[j], A[i]).

class Solution {
    public int numberOfArithmeticSlices(int[] a) {
     	int[] q = new int[a.length];
     	for(int i=2;i<a.length;i++){
     		if()
     	}
    	if(a==null||a.length<3){
    		return 0;
    	}
        int p = a[0]-a[1];
        if(p==0){
        	return a.length+1-3;
        }
        
        int t = 0;
        for(int i =3;i<a.length;i++){
        	int j = 0;
        	
        	while(i+(i-1)*j<=a.length){
	        	t+=a.length-i-(i-1)*j+1;
        	}
        }
        
        return t;
    }
}

Number of Boomerangs
Easy
Given n points in the plane that are all pairwise distinct, a "boomerang" is a tuple of points (i, j, k) such that the distance between i and j equals the distance between i and k (the order of the tuple matters).

Find the number of boomerangs. You may assume that n will be at most 500 and coordinates of points are all in the range [-10000, 10000] (inclusive).

Example:

Input:
[[0,0],[1,0],[2,0]]

Output:
2

Explanation:
The two boomerangs are [[1,0],[0,0],[2,0]] and [[1,0],[2,0],[0,0]]

class Solution {
    public int numberOfBoomerangs(int[][] points) {
        int r=0;
        for(int i = 0;i<points.length;i++){
        Map<Integer,Integer> map = new HashMap<>();
        	for(int j=0;j<points.length;j++){
        		int k = points[i][0]-points[j][0];
        		int f = points[i][1]-points[j][1];
        		map.put(k*k+f*f,map.getOrDefault(k*k+f*f,0)+1);
        	}
	        for(int q : map.values()){
	        	r+=q*(q-1);
	        }
        }
        
        return r;
    }
}

448. Find All Numbers Disappeared in an Array
Easy
1653
159
Given an array of integers where 1 ≤ a[i] ≤ n (n = size of array), some elements appear twice and others appear once.

Find all the elements of [1, n] inclusive that do not appear in this array.

Could you do it without extra space and in O(n) runtime? You may assume the returned list does not count as extra space.

Example:

Input:
[4,3,2,7,8,2,3,1]

Output:
[5,6]

class Solution {
    public List<Integer> findDisappearedNumbers(int[] nums) {
        List<Integer> list = new ArrayList<>();
        for(int i = 0;i<nums.length;i++){
        	if(nums[i]!=0&&i+1!=nums[i]){
        		int t = nums[i];
        		if(nums[t-1]==t){
        			nums[i]=0;
        			continue;
        		}
        		nums[i]=nums[t-1];
        		nums[t-1]=t;
        		i--;
        	}
        }
        
        for(int i = 0;i<nums.length;i++){
        	if(nums[i]==0){
        		list.add(i);
        	}
        }
        
        return list;
    }
}

449. Serialize and Deserialize BST
Medium
636
47
Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment.

Design an algorithm to serialize and deserialize a binary search tree. There is no restriction on how your serialization/deserialization algorithm should work. You just need to ensure that a binary search tree can be serialized to a string and this string can be deserialized to the original tree structure.

The encoded string should be as compact as possible.

Note: Do not use class member/global/static variables to store states. Your serialize and deserialize algorithms should be stateless.

Hi all, I think my solution is pretty straightforward and easy to understand, not that efficient though. And the serialized tree is compact.
Pre order traversal of BST will output root node first, then left children, then right.

root left1 left2 leftX right1 rightX
If we look at the value of the pre-order traversal we get this:

rootValue (<rootValue) (<rootValue) (<rootValue) |separate line| (>rootValue) (>rootValue)
Because of BST's property: before the |separate line| all the node values are less than root value, all the node values after |separate line| are greater than root value. We will utilize this to build left and right tree.

Pre-order traversal is BST's serialized string. I am doing it iteratively.
To deserialized it, use a queue to recursively get root node, left subtree and right subtree.

I think time complexity is O(NlogN).
Errr, my bad, as @ray050899 put below, worst case complexity should be O(N^2), when the tree is really unbalanced.

My implementation

public class Codec {
    private static final String SEP = ",";
    private static final String NULL = "null";
    // Encodes a tree to a single string.
    public String serialize(TreeNode root) {
        StringBuilder sb = new StringBuilder();
        if (root == null) return NULL;
        //traverse it recursively if you want to, I am doing it iteratively here
        Stack<TreeNode> st = new Stack<>();
        st.push(root);
        while (!st.empty()) {
            root = st.pop();
            sb.append(root.val).append(SEP);
            if (root.right != null) st.push(root.right);
            if (root.left != null) st.push(root.left);
        }
        return sb.toString();
    }

    // Decodes your encoded data to tree.
    // pre-order traversal
    public TreeNode deserialize(String data) {
        if (data.equals(NULL)) return null;
        String[] strs = data.split(SEP);
        Queue<Integer> q = new LinkedList<>();
        for (String e : strs) {
            q.offer(Integer.parseInt(e));
        }
        return getNode(q);
    }
    
    // some notes:
    //   5
    //  3 6
    // 2   7
    private TreeNode getNode(Queue<Integer> q) { //q: 5,3,2,6,7
        if (q.isEmpty()) return null;
        TreeNode root = new TreeNode(q.poll());//root (5)
        Queue<Integer> samllerQueue = new LinkedList<>();
        while (!q.isEmpty() && q.peek() < root.val) {
            samllerQueue.offer(q.poll());
        }
        //smallerQueue : 3,2   storing elements smaller than 5 (root)
        root.left = getNode(samllerQueue);
        //q: 6,7   storing elements bigger than 5 (root)
        root.right = getNode(q);
        return root;
    }
}

/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Codec {

    // Encodes a tree to a single string.
    public String serialize(TreeNode root) {
    	if(root==null)return null;
    	String s = root.val+",";
    	if(root.left!=null)s+=serialize(root.left);
    	if(root.right!=null)s+=serialize(root.right);
    	return s;
    }
    
    
    // Decodes your encoded data to tree.
    public TreeNode deserialize(String data) {
    	if(data==null)return null;
    	Queue<Integer> q = new LinkedList<>();
    	for(String s : data.split(",")){
    		q.push(Integer.value(s));
    	}
    	return q(q);
    }
    
    private TreeNode q(Queue<Integer> q){
    	if(q.isEmpty())return null;
    	TreeNode t = new TreeNode(q.poll());
    	Queue<Integer> l = new LinkedList<>();
    	while(!q.isEmpty()&&q.peek()<t.val){
    		l.add(q.poll());
    	}
    	
    	t.left=q(l);
    	t.right=q(q);
    	return t;
    }
    
}

// Your Codec object will be instantiated and called as such:
// Codec codec = new Codec();
// codec.deserialize(codec.serialize(root));

Delete Node in a BST
Medium
924
59
Given a root node reference of a BST and a key, delete the node with the given key in the BST. Return the root node reference (possibly updated) of the BST.

Basically, the deletion can be divided into two stages:

Search for a node to remove.
If the node is found, delete the node.
Note: Time complexity should be O(height of tree).

Example:

root = [5,3,6,2,4,null,7]
key = 3

    5
   / \
  3   6
 / \   \
2   4   7

Given key to delete is 3. So we find the node with value 3 and delete it.

One valid answer is [5,4,6,2,null,null,7], shown in the following BST.

    5
   / \
  4   6
 /     \
2       7

Another valid answer is [5,2,6,null,4,null,7].

    5
   / \
  2   6
   \   \
    4   7
Accepted
67,466
Submissions
168,269

/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public TreeNode deleteNode(TreeNode root, int key) {
    	if(root==null){
    		return null;
    	}
    	
    	if(root.val>key){
    		root.left=deleteNode(root.left,key);
    	}else if(root.val<key){
			root.right=deleteNode(root.right,key);    	
    	}else{
    		if(root.left==null){
    			return root.right;
    		}else if(root.right==null){
    			return root.left;
    		}else{
    		    TreeNode m = find(root.right);
    		    root.val=m.val;
    		    root.right=deleteNode(root.right,m.val);
    		}
    	}
    	return root;
    	
    }
    
    public TreeNode find(TreeNode r){
    	while(r.left!=null){
    		r=r.left;
    	}
    	return r;
    }
    
    public TreeNode q(TreeNode q,TreeNode w,int key){
    	if(w==null)return w;
    	if(w.val==key){
    		if(q==null){
    			TreeNode l = q(q,w.left,key);
    			TreeNode r = q(q,w.right,key);
    			if(l!=null){
	    			l.right=r;
    			}else{
    				l=r;
    			}
    			return l;
    		}else{
    			if(w.left==null&&w.right==null){
    				if(q.left==w){
    					q.left=null;
    				}else{
    					q.right=null;
    				}
    				return q;
    			}
    			TreeNode l = q(w,w.left,key);
    			TreeNode r = q(w,w.right,key);
    			if(l!=null){
    				l.right=r;
    			}else{
    				l=r;
    			}
    			return q;
    		}
    	}else{
    		q(w,w.left,key);
    		q(w,w.right,key);
    		return w;
    	}
    	return w;
    }
}

Steps:

Recursively find the node that has the same value as the key, while setting the left/right nodes equal to the returned subtree
Once the node is found, have to handle the below 4 cases
node doesn't have left or right - return null
node only has left subtree- return the left subtree
node only has right subtree- return the right subtree
node has both left and right - find the minimum value in the right subtree, set that value to the currently found node, then recursively delete the minimum value in the right subtree
public TreeNode deleteNode(TreeNode root, int key) {
    if(root == null){
        return null;
    }
    if(key < root.val){
        root.left = deleteNode(root.left, key);
    }else if(key > root.val){
        root.right = deleteNode(root.right, key);
    }else{
        if(root.left == null){
            return root.right;
        }else if(root.right == null){
            return root.left;
        }
        
        TreeNode minNode = findMin(root.right);
        root.val = minNode.val;
        root.right = deleteNode(root.right, root.val);
    }
    return root;
}

private TreeNode findMin(TreeNode node){
    while(node.left != null){
        node = node.left;
    }
    return node;
}

451. Sort Characters By Frequency
Medium

742

64
Given a string, sort it in decreasing order based on the frequency of characters.

Example 1:

Input:
"tree"

Output:
"eert"

Explanation:
'e' appears twice while 'r' and 't' both appear once.
So 'e' must appear before both 'r' and 't'. Therefore "eetr" is also a valid answer.
Example 2:

Input:
"cccaaa"

Output:
"cccaaa"

Explanation:
Both 'c' and 'a' appear three times, so "aaaccc" is also a valid answer.
Note that "cacaca" is incorrect, as the same characters must be together.
Example 3:

Input:
"Aabb"

Output:
"bbAa"

Explanation:
"bbaA" is also a valid answer, but "Aabb" is incorrect.
Note that 'A' and 'a' are treated as two different characters.
class Solution {
    public String frequencySort(String s) {
        Map<Character,Integer> map = new HashMap<>();
        for(char c : s.toCharArray()){
            map.put(c,map.getOrDefault(c,0)+1);
        }

        Map<Integer,StringBuilder> t = new TreeMap<>();
        for(Entry<Character,Integer> e : map.entrySet()){
            StringBuilder l = t.get(e.getValue());
            if(l==null){
                l=new StringBuilder();
                t.put(e.getValue(),l);
            }
            StringBuilder sb = new StringBuilder();
            for(int i = 0;i<e.getValue();i++){
                sb.append(e.getKey());
            }
            l.append(sb.toString());
        }

        StringBuilder sb = new StringBuilder();
        for(Integer i : t.keys()){
            sb.append(0,t.get(i));
        }
        return sb.toString();
    }
}

452. Minimum Number of Arrows to Burst Balloons
Medium
499
26
There are a number of spherical balloons spread in two-dimensional space. For each balloon, provided input is the start and end coordinates of the horizontal diameter. Since it's horizontal, y-coordinates don't matter and hence the x-coordinates of start and end of the diameter suffice. Start is always smaller than end. There will be at most 104 balloons.

An arrow can be shot up exactly vertically from different points along the x-axis. A balloon with xstart and xend bursts by an arrow shot at x if xstart ≤ x ≤ xend. There is no limit to the number of arrows that can be shot. An arrow once shot keeps travelling up infinitely. The problem is to find the minimum number of arrows that must be shot to burst all balloons.

Example:

Input:
[[10,16], [2,8], [1,6], [7,12]]

Output:
2

Explanation:
One way is to shoot one arrow for example at x = 6 (bursting the balloons [2,8] and [1,6]) and another arrow at x = 11 (bursting the other two balloons).
class Solution {
    public int findMinArrowShots(int[][] points) {
        Arrays.sort(points,new Comparator<int[]>(){
            @Override
            public int compare(int[] q,int[] w){
                return q[1]-w[1];
            }
        });
        int q = 1;
        int e = points[0][1];
        for(int i = 1;i<points.length;i++){
            if(e<points[i][0]){
                q++;
                e=points[i][1];
            }
        }
        return q;
    }

}

453. Minimum Moves to Equal Array Elements
Easy
Given a non-empty integer array of size n, find the minimum number of moves required to make all array elements equal, where a move is incrementing n - 1 elements by 1.

Example:

Input:
[1,2,3]

Output:
3

Explanation:
Only three moves are needed (remember each move increments two elements):

[1,2,3]  =>  [2,3,3]  =>  [3,4,3]  =>  [4,4,4]

let's define sum as the sum of all the numbers, before any moves; minNum as the min number int the list; n is the length of the list;

After, say m moves, we get all the numbers as x , and we will get the following equation

 sum + m * (n - 1) = x * n
and actually,

  x = minNum + m
This part may be a little confusing, but @shijungg explained very well. let me explain a little again. it comes from two observations:

the minum number will always be minum until it reachs the final number, because every move, other numbers (besides the max) will be increamented too;
from above, we can get, the minum number will be incremented in every move. So, if the final number is x, it would be minNum + moves;
and finally, we will get

  sum - minNum * n = m
This is just a math calculation.

class Solution {
    public int minMoves(int[] nums) {
        int q = 0;
        int m = nums[0];
        for(int i : nums){
            q+=i;
            m=Math.min(i,m);
        }

        return q-m*nums.length;
        
    }
}

454. 4Sum II
Medium

698

59
Given four lists A, B, C, D of integer values, compute how many tuples (i, j, k, l) there are such that A[i] + B[j] + C[k] + D[l] is zero.

To make problem a bit easier, all A, B, C, D have same length of N where 0 ≤ N ≤ 500. All integers are in the range of -228 to 228 - 1 and the result is guaranteed to be at most 231 - 1.

Example:

Input:
A = [ 1, 2]
B = [-2,-1]
C = [-1, 2]
D = [ 0, 2]

Output:
2

Explanation:
The two tuples are:
1. (0, 0, 0, 1) -> A[0] + B[0] + C[0] + D[1] = 1 + (-2) + (-1) + 2 = 0
2. (1, 1, 0, 0) -> A[1] + B[1] + C[0] + D[0] = 2 + (-1) + (-1) + 0 = 0

class Solution {
    public int fourSumCount(int[] A, int[] B, int[] C, int[] D) {

         Map<Long,Integer> i1 = new HashMap<>(),i2 = new HashMap<>();
        for(int i = 0 ;i<A.length;i++){
            for(int j =0;j<A.length;j++){
                long key1 = (long)A[i]+B[j];
                long key2 = (long)C[i]+D[j];
                i1.put(key1,i1.getOrDefault(key1,0)+1);
                i2.put(key2,i2.getOrDefault(key2,0)+1);
            }
        }

        int s = 0;
        for(Map.Entry<Long,Integer> entry: i1.entrySet()){
            Integer i = i2.get(-entry.getKey());
            if(i!=null){
                s+=i*entry.getValue();
            }
        }
        
        return s;
    }


    public Map<Long,Integer> q(int[] a,int[] b){
        Map<Long,Integer> map = new HashMap<>();
        for(int i : a){
            for(int j : b){
                long key = (long)i+j;
                map.put(key,map.getOrDefault(key,0)+1);
            }
        }
        return map;
    }
}

455. Assign Cookies
Easy

327

67
Assume you are an awesome parent and want to give your children some cookies. But, you should give each child at most one cookie. Each child i has a greed factor gi, which is the minimum size of a cookie that the child will be content with; and each cookie j has a size sj. If sj >= gi, we can assign the cookie j to the child i, and the child i will be content. Your goal is to maximize the number of your content children and output the maximum number.

Note:
You may assume the greed factor is always positive. 
You cannot assign more than one cookie to one child.

Example 1:
Input: [1,2,3], [1,1]

Output: 1

Explanation: You have 3 children and 2 cookies. The greed factors of 3 children are 1, 2, 3. 
And even though you have 2 cookies, since their size is both 1, you could only make the child whose greed factor is 1 content.
You need to output 1.
Example 2:
Input: [1,2], [1,2,3]

Output: 2

Explanation: You have 2 children and 3 cookies. The greed factors of 2 children are 1, 2. 
You have 3 cookies and their sizes are big enough to gratify all of the children, 
You need to output 2.

class Solution {
    public int findContentChildren(int[] g, int[] s) {
        Arrays.sort(g);
        Arrays.sort(s);
        int i = 0;
        int j = 0;
        for(ing q : g){
            for(;j<s.length;){
                if(q<=s[j]){
                    j++;
                    break;
                }
                j++;
            }
            if(j==s.length-1)return i;
        }
        return i;
    }
}

456. 132 Pattern
Medium

654

39
Given a sequence of n integers a1, a2, ..., an, a 132 pattern is a subsequence ai, aj, ak such that i < j < k and ai < ak < aj. Design an algorithm that takes a list of n numbers as input and checks whether there is a 132 pattern in the list.

Note: n will be less than 15,000.

Example 1:
Input: [1, 2, 3, 4]

Output: False

Explanation: There is no 132 pattern in the sequence.
Example 2:
Input: [3, 1, 4, 2]

Output: True

Explanation: There is a 132 pattern in the sequence: [1, 4, 2].
Example 3:
Input: [-1, 3, 2, 0]

Output: True

Explanation: There are three 132 patterns in the sequence: [-1, 3, 2], [-1, 3, 0] and [-1, 2, 0].

class Solution {
    public boolean find132pattern(int[] nums) {
        if(nums==null||nums.length<3)return false;
        int f =nums[nums.length-1];
        int m = Integer.MAX_VALUE;
        for(int i = 0;i<nums.length-2;i++){
            m=Math.Min(m,nums[i]);
        }
        for(int i = nums.length-2;i>0;i--){
            if(nums[i]>f){
                for(int j = i+1;j<nums.length;j++){
                    if(nums[i]>nums[j]&&nums[j]>f){
                        return true;
                    }
                }    

            }else{
                f=nums[i];
            }
        }

        return false;
    }
}

This is a summary of the four solutions for this problem. It starts with the O(n^3) naive solution, then transition to the O(n^2) sub-optimal solution and finally to the two optimized O(n) solutions (one is two-pass while the other is one-pass).

I. Naive O(n^3) solution

The naive O(n^3) solution is a no-brainer --- simply check every (i, j, k) combination to see if there is any 132 pattern.

public boolean find132pattern(int[] nums) {
    for (int i = 0; i < nums.length; i++) {
        for (int j = i + 1; j < nums.length; j++) {
            for (int k = j + 1; k < nums.length; k++) {
                if (nums[i] < nums[k] && nums[k] < nums[j]) return true;
            }
        }
    }
    return false;
}
And of course it will get rejected due to TLE. So let's see how we can do better.

II. Improved O(n^2) solution

To reduce the time complexity down to O(n^2), we need to do some observations. In the naive solution above, let's assume we have index j fixed, what should index i be so that it is most probable we will have a 132 pattern? Or in other words, what should i be so that we will be certain there is no such 132 pattern for combination (*, j, *) whenever there is no 132 pattern for combination of (i, j, *)? (Here * means any index before or after index j.)

The answer lies in the fact that once the first two numbers nums[i] and nums[j] are fixed, we are up to find the third number nums[k] which will be within the range (nums[i], nums[j]) (the two boundaries are exclusive). Intuitively the larger the range is, the more likely there will be a number "falling into" it. Therefore we need to choose index i which will maximize the range (nums[i], nums[j]). Since the upper bound nums[j] is fixed, this is equivalent to minimizing the lower bound nums[i]. Thus it is clear i should be the index of the minimum element of the subarray nums[0, j) (left inclusive, right exclusive).

Since we are scanning index j from the beginning of the input array nums, we can keep track of the minimum element of the subarray from index 0 up to j - 1 without rescanning it. Therefore the first two loops in the naive solution can be combined into one and leads to the following O(n^2) solution:

public boolean find132pattern(int[] nums) {
    for (int j = 0, min = Integer.MAX_VALUE; j < nums.length; j++) {
         min = Math.min(nums[j], min);
         if (min == nums[j]) continue;
         
         for (int k = nums.length - 1; k > j; k--) {
             if (min < nums[k] && nums[k] < nums[j]) return true;
         }
     }
     
     return false;
}
While this solution can be accepted, it runs slow. One obvious drawback is that in the second loop we are throwing away information about elements in the right part of nums that may be "useful" for later combinations. It turns out we can retain this "useful" information by applying the classic space-time tradeoff, which leads to the following O(n) time and O(n) space solution.

III. Optimized O(n) solution

As I mentioned, to further reduce the time complexity, we need to record the "useful" information about elements in the right part of the input array nums. Since these elements are located at the right part of nums, it will be hard to do so if we are scanning the array from the beginning. So the idea is to scan it from the end while in the meantime keep track of the "useful" information. But still at each index j, we need to know the minimum element for subarray nums[0, j). This can be done by doing a pre-scan in the forward direction and memorize the results for each index in an auxiliary array (we will call the array as arr whose element arr[j] will denote the minimum element in the subarray nums[0, j)).

Until now we are kinda vague about the exact meaning of "useful" information, so let's try to be more specific. Assume we're currently scanning (from the end) the element with index j, our task is to find two elements nums[i] and nums[k] to determine if there exists a 132 pattern, with i < j < k. The left element nums[i], as it has been shown in part II, will be chosen as arr[j], the minimum element of subarray nums[0, j). What about the right element nums[k]?

The answer to that will address the meaning of "useful" information. First note we are only interested in elements that are greater than arr[j], so it is sensible to maintain only those elements. Second, among all these qualified elements, which one will be the most probable to fall into the range (nums[i], nums[j])? I would say it is the smallest one (i.e., if the smallest one is out of the range, all others will also be out of range). So to sum up, the "useful" information for current index j will be a collection of scanned elements that are greater than arr[j], and nums[k] will be chosen as the smallest one if the collection is not empty.

From the analyses above, it looks like we have to do some sorting stuff for the retained elements (or at least find a way to figure out its smallest element). Well, it turns out these elements will be sorted automatically due to the fact that arr[j'] >= arr[j] as long as j' < j. Here is how it goes, which is a proof by induction.

At the beginning we have an empty collection and of course it is sorted. Now suppose we are at index j and the corresponding collection is still sorted, let's see if it remains so at index j - 1. First we will check if nums[j] is greater than arr[j]. If not, we simply continue to j - 1. Since the collection is intact so it will be sorted at j - 1. Otherwise, we need to remove elements in the collection that are no greater than arr[j] (this is necessary because some smaller elements may be left over in the collection from previous steps). After removal, we then compare the first element in the collection with nums[j] to see if a 132 pattern has been found, provided the collection is not empty. If so, return true. Otherwise one of the following must be true: the collection is empty or nums[j] is no greater than the first element in the collection. In either case the collection is sorted. Now if we have arr[j - 1] < nums[j], we need to add nums[j] to the collection since it is a qualified number for arr[j - 1]. Again in either case the collection will remain sorted after addition (if it is empty, after addition there is only one element; otherwise since the added element is no greater than the first element in the collection before addition, it will become the new first element after addition and the collection stays sorted).

Here is the program with O(n) time and space complexity. There is one minor optimization based on the observation that the total number of elements in the collection will never exceed the total number of elements scanned so far. Therefore the right part of the arr array can be used to serve as the collection. For time complexity, each element in the input array nums will be pushed into and popped out from the collection (or stack to be exact) at most once, the time complexity will be O(n) despite of the nested loop.

public boolean find132pattern(int[] nums) {
    int[] arr = Arrays.copyOf(nums, nums.length);

    for (int i = 1; i < nums.length; i++) {
        arr[i] = Math.min(nums[i - 1], arr[i - 1]);
    }
    
    for (int j = nums.length - 1, top = nums.length; j >= 0; j--) {
        if (nums[j] <= arr[j]) continue;
        while (top < nums.length && arr[top] <= arr[j]) top++;
        if (top < nums.length && nums[j] > arr[top]) return true;
        arr[--top] = nums[j];
    }
        
    return false;
}
IV -- One-pass O(n) solution

It turned out that we don't need the arr array in part III, thus can get rid of the pre-scan. The idea is to do backward traversal of the input array and keep track of the maximum value (denoted as third) of all possible third numbers obtained so far (an element can be a candidate for the third number if and only if there is another element coming before and greater than it). This is because for two candidate third numbers a and b, if a <= b and there is no 132 pattern for b, then there must be no 132 pattern for a either. The idea is elaborated as follows.

For the current element being examined, we first check if it can be the first number by comparing it with third. If this is the case, a 132 pattern has been found. Otherwise, it will be treated as the second number to qualify scanned elements so far as candidate third numbers (note we are doing backward scan so the current element will always come before scanned elements). Of course we cannot do this for all scanned elements, as it will lead to an O(n^2) solution. Fortunately it suffices only to process scanned elements that are greater than third. This is because after an element is qualified to be the third number, it will only be used to update third. For those elements smaller than third, even if they are qualified to be the third number, they won't make third any larger and therefore can be ignored.

So we need to maintain a collection (stack, to be exact) for scanned elements that are greater than third. After the current element is done, it will be added to this collection for future processing. It can be shown by mathematical induction that elements in the collection will be sorted automatically, similar to that in part III. At the beginning the collection is empty so the base case is true. Assume the collection is sorted immediately before processing the current element, which is presumed to be >= third (otherwise a 132 pattern is found). We will scan the collection and pop out all elements smaller than the current element to find all qualified third numbers and update third accordingly. At the end, all remaining elements in the collection are no less than the current element, therefore adding the current element to the collection won't break the sorted property. So our induction assumption is also true.

Here is the one-pass O(n) solution. We can also optimize the space cost to O(1) if the input array can act as the collection by taking advantage of the fact that size of the collection will never exceed the number of elements scanned so far.

public boolean find132pattern(int[] nums) {
    int n = nums.length, top = n, third = Integer.MIN_VALUE;

    for (int i = n - 1; i >= 0; i--) {
        if (nums[i] < third) return true;
        while (top < n && nums[i] > nums[top]) third = nums[top++];
        nums[--top] = nums[i];
    }
    
    return false;
}

457. Circular Array Loop
Medium
You are given a circular array nums of positive and negative integers. If a number k at an index is positive, then move forward k steps. Conversely, if it's negative (-k), move backward k steps. Since the array is circular, you may assume that the last element's next element is the first element, and the first element's previous element is the last element.

Determine if there is a loop (or a cycle) in nums. A cycle must start and end at the same index and the cycle's length > 1. Furthermore, movements in a cycle must all follow a single direction. In other words, a cycle must not consist of both forward and backward movements.

 

Example 1:

Input: [2,-1,1,2,2]
Output: true
Explanation: There is a cycle, from index 0 -> 2 -> 3 -> 0. The cycle's length is 3.
Example 2:

Input: [-1,2]
Output: false
Explanation: The movement from index 1 -> 1 -> 1 ... is not a cycle, because the cycle's length is 1. By definition the cycle's length must be greater than 1.
Example 3:

Input: [-2,1,-1,-2,-2]
Output: false
Explanation: The movement from index 1 -> 2 -> 1 -> ... is not a cycle, because movement from index 1 -> 2 is a forward movement, but movement from index 2 -> 1 is a backward movement. All movements in a cycle must follow a single direction.
 

Note:

-1000 ≤ nums[i] ≤ 1000
nums[i] ≠ 0
1 ≤ nums.length ≤ 5000
 

Follow up:

Could you solve it in O(n) time complexity and O(1) extra space complexity?

Just think it as finding a loop in Linkedlist, except that loops with only 1 element do not count. Use a slow and fast pointer, slow pointer moves 1 step a time while fast pointer moves 2 steps a time. If there is a loop (fast == slow), we return true, else if we meet element with different directions, then the search fail, we set all elements along the way to 0. Because 0 is fail for sure so when later search meet 0 we know the search will fail.

public class Solution {
    public boolean circularArrayLoop(int[] nums) {
        int n = nums.length;
        for (int i = 0; i < n; i++) {
            if (nums[i] == 0) {
                continue;
            }
            // slow/fast pointer
            int j = i, k = getIndex(i, nums);
            while (nums[k] * nums[i] > 0 && nums[getIndex(k, nums)] * nums[i] > 0) {
                if (j == k) {
                    // check for loop with only one element
                    if (j == getIndex(j, nums)) {
                        break;
                    }
                    return true;
                }
                j = getIndex(j, nums);
                k = getIndex(getIndex(k, nums), nums);
            }
            // loop not found, set all element along the way to 0
            j = i;
            int val = nums[i];
            while (nums[j] * val > 0) {
                int next = getIndex(j, nums);
                nums[j] = 0;
                j = next;
            }
        }
        return false;
    }
    
    public int getIndex(int i, int[] nums) {
        int n = nums.length;
        return i + nums[i] >= 0? (i + nums[i]) % n: n + ((i + nums[i]) % n);
    }
}

class Solution {
    public boolean circularArrayLoop(int[] nums) {
        int n = nums.length;
        for(int i =0;i<n;i++){
            if(nums[i]==0)continue;
            int j = i,q = q(i,nums);
            while(nums[i]*nums[q]>0&&nums[i]*nums[q(q,nums)]>0){
                if(j==q){
                    if(q(j,nums)==j){
                        break;
                    }
                    
                    return true;
                }
                j=q(j,nums);
                q=q(q(q,nums),nums);

            }

            j = i;
            int v = nums[i];
            while(nums[j]*v>0){
                int y = q(j,nums);
                nums[j]=0;
                j=y;
            }
        }

        return false;


    }

    public int q(int j,int[] nums){
        int k = (j +nums[j])%nums.length;
        return k>=0?k:nums.length+k;
    }

}

458. Poor Pigs
Hard
There are 1000 buckets, one and only one of them is poisonous, while the rest are filled with water. They all look identical. If a pig drinks the poison it will die within 15 minutes. What is the minimum amount of pigs you need to figure out which bucket is poisonous within one hour?

Answer this question, and write an algorithm for the general case.

 

General case:

If there are n buckets and a pig drinking poison will die within m minutes, how many pigs (x) you need to figure out the poisonous bucket within p minutes? There is exactly one bucket with poison.

 

Note:

A pig can be allowed to drink simultaneously on as many buckets as one would like, and the feeding takes no time.
After a pig has instantly finished drinking buckets, there has to be a cool down time of m minutes. During this time, only observation is allowed and no feedings at all.
Any given bucket can be sampled an infinite number of times (by an unlimited number of pigs).
Accepted

class Solution {
    public int poorPigs(int buckets, int minutesToDie, int minutesToTest) {
        
    }
}

459. Repeated Substring Pattern
Easy

831

100

Favorite

Share
Given a non-empty string check if it can be constructed by taking a substring of it and appending multiple copies of the substring together. You may assume the given string consists of lowercase English letters only and its length will not exceed 10000.

 

Example 1:

Input: "abab"
Output: True
Explanation: It's the substring "ab" twice.
Example 2:

Input: "aba"
Output: False
Example 3:

Input: "abcabcabcabc"
Output: True
Explanation: It's the substring "abc" four times. (And the substring "abcabc" twice.)

lastindexof
class Solution {
    public boolean repeatedSubstringPattern(String s) {
        for(int i = s.length()/2;i>0;i--){
            if(s.length()%i==0){
                int m = s.length()/i;
                String ss = s.substring(0,i);
                StringBuilder sb = new StringBuilder();
                for(int j=0;j<m;j++){
                    sb.append(ss);
                }
                if(sb.toString().equals(s))return true;

            }
        }

        return false;
    }
}

460. LFU Cache
Hard

714

79

Favorite

Share
Design and implement a data structure for Least Frequently Used (LFU) cache. It should support the following operations: get and put.

get(key) - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1.
put(key, value) - Set or insert the value if the key is not already present. When the cache reaches its capacity, it should invalidate the least frequently used item before inserting a new item. For the purpose of this problem, when there is a tie (i.e., two or more keys that have the same frequency), the least recently used key would be evicted.

Follow up:
Could you do both operations in O(1) time complexity?

Example:

LFUCache cache = new LFUCache( 2 /* capacity */ );

cache.put(1, 1);
cache.put(2, 2);
cache.get(1);       // returns 1
cache.put(3, 3);    // evicts key 2
cache.get(2);       // returns -1 (not found)
cache.get(3);       // returns 3.
cache.put(4, 4);    // evicts key 1.
cache.get(1);       // returns -1 (not found)
cache.get(3);       // returns 3
cache.get(4);       // returns 4

class LFUCache {

    T f;
    int c;
    public LFUCache(int capacity) {
        c = capacity;
    }
    
    public int get(int key) {
        T t = f;
        while(t!=null){
            if(t.k==key){
                if(t.p!=null){
                    t.p.n=t.n;
                    if(t.n!=null){
                        t.n.p=t.p;
                    }
                }
                
                if(f!=t&&f!=null){
                    f.p=t;
                    t.n=f;
                    t.p=null;
                }
                f=t;
                return t.v;
            }
            t=t.n;
        }
        return -1;
        
    }
    
    public void put(int key, int value) {
        T t = f;
        while(t!=null){
            if(t.k==key){
                t.v=value;
                break;
            }
            t=t.n;
        }

        if(t!=null){
            if(t.p!=null){
                t.p.n=t.n;
                if(t.n!=null){
                    t.n.p=t.p;
                }
            }
            
        }else{
            t=new T();
            t.k=key;
            t.v=value;
            if(c==0){
                T q = f;
                while(q!=null){
                    if(q.n==null){
                        if(q.p==null){
                            f=null;
                        }else{
                             q.p.n=null;
                        }
                       
                        break;
                    }
                    q=q.n;
                }
            }else{
                c--;
            }
        }
        if(f!=t&&f!=null){
            f.p=t;
            t.n=f;
            t.p=null;
        }

        f=t;

        
        
    }
}
  HashMap<Integer, Integer> vals;
    HashMap<Integer, Integer> counts;
    HashMap<Integer, LinkedHashSet<Integer>> lists;
    int cap;
    int min = -1;
    public LFUCache(int capacity) {
        cap = capacity;
        vals = new HashMap<>();
        counts = new HashMap<>();
        lists = new HashMap<>();
        lists.put(1, new LinkedHashSet<>());
    }
    
    public int get(int key) {
        if(!vals.containsKey(key))
            return -1;
        int count = counts.get(key);
        counts.put(key, count+1);
        lists.get(count).remove(key);
        if(count==min && lists.get(count).size()==0)
            min++;
        if(!lists.containsKey(count+1))
            lists.put(count+1, new LinkedHashSet<>());
        lists.get(count+1).add(key);
        return vals.get(key);
    }
    
    public void set(int key, int value) {
        if(cap<=0)
            return;
        if(vals.containsKey(key)) {
            vals.put(key, value);
            get(key);
            return;
        } 
        if(vals.size() >= cap) {
            int evit = lists.get(min).iterator().next();
            lists.get(min).remove(evit);
            vals.remove(evit);
        }
        vals.put(key, value);
        counts.put(key, 1);
        min = 1;
        lists.get(1).add(key);
    }
class T{
    T p;
    T n;
    int k;
    int v;
}

class T extends Comparator<T>{
    int k;
    int v;

    public int compare(T t1,T t2){
        return t1.k-t2.k;
    }
}


class LFUCache {

    public LFUCache(int capacity) {
        
    }
    
    public int get(int key) {
        
    }
    
    public void put(int key, int value) {
        
    }
}

class T extends Comparator<T>{
    int k;
    int v;

    public int compare(T t1,T t2){
        return t1.k-t2.k;
    }
}

/**
 * Your LFUCache object will be instantiated and called as such:
 * LFUCache obj = new LFUCache(capacity);
 * int param_1 = obj.get(key);
 * obj.put(key,value);
 */

 461. Hamming Distance
Easy

1343

122

The Hamming distance between two integers is the number of positions at which the corresponding bits are different.

Given two integers x and y, calculate the Hamming distance.

Note:
0 ≤ x, y < 231.

Example:

Input: x = 1, y = 4

Output: 2

Explanation:
1   (0 0 0 1)
4   (0 1 0 0)
       ↑   ↑

The above arrows point to positions where the corresponding bits are different.

class Solution {
    public int hammingDistance(int x, int y) {
        int q = x ^ y ;
        int z = 0;
        while(q!=0){
            if((q&1)==1){
               z++;
            }
            q>>=1;
           
        }

        return t;
    }
}

462. Minimum Moves to Equal Array Elements II
Medium

365

31
Given a non-empty integer array, find the minimum number of moves required to make all array elements equal, where a move is incrementing a selected element by 1 or decrementing a selected element by 1.

You may assume the array's length is at most 10,000.

Example:

Input:
[1,2,3]

Output:
2

Explanation:
Only two moves are needed (remember each move increments or decrements one element):

[1,2,3]  =>  [2,2,3]  =>  [2,2,2]

[1,0,0,8,6]
class Solution {
    public int minMoves2(int[] nums) {
        Arrays.sort(nums);
        int i=0,j=nums.length-1;
        int s = 0;
        while(i<j){
            s+=nums[j--]-nums[i--];
        }
        return s;
    }
}

463. Island Perimeter
Easy
1138
86
You are given a map in form of a two-dimensional integer grid where 1 represents land and 0 represents water.

Grid cells are connected horizontally/vertically (not diagonally). The grid is completely surrounded by water, and there is exactly one island (i.e., one or more connected land cells).

The island doesn't have "lakes" (water inside that isn't connected to the water around the island). One cell is a square with side length 1. The grid is rectangular, width and height don't exceed 100. Determine the perimeter of the island.

 

Example:

Input:
[[0,1,0,0],
 [1,1,1,0],
 [0,1,0,0],
 [1,1,0,0]]

Output: 16

Explanation: The perimeter is the 16 yellow stripes in the image below:

class Solution {
    public int islandPerimeter(int[][] grid) {
        int s = 0;
        for(int i =0;i<grid.length;i++){
            for(int j = 0;j<grid[0].length;j++){
                if(grid[i][j]==1){
                    if(i==0||grid[i-1][j]==0){
                        s++;
                    }

                    if(i==grid.length-1||grid[i+1][j]==0){
                        s++;
                    }

                    if(j==0||grid[i][j-1]==0){
                        s++;
                    }

                    if(j==grid[0].length-1||grid[i][j+1]==0)s++;
                }
            }
        }

        return s;
    }
}

464. Can I Win
Medium

651

115

Favorite

Share
In the "100 game," two players take turns adding, to a running total, any integer from 1..10. The player who first causes the running total to reach or exceed 100 wins.

What if we change the game so that players cannot re-use integers?

For example, two players might take turns drawing from a common pool of numbers of 1..15 without replacement until they reach a total >= 100.

Given an integer maxChoosableInteger and another integer desiredTotal, determine if the first player to move can force a win, assuming both players play optimally.

You can always assume that maxChoosableInteger will not be larger than 20 and desiredTotal will not be larger than 300.

Example

Input:
maxChoosableInteger = 10
desiredTotal = 11

Output:
false

Explanation:
No matter which integer the first player choose, the first player will lose.
The first player can choose an integer from 1 up to 10.
If the first player choose 1, the second player can only choose integers from 2 up to 10.
The second player will win by choosing 10 and get a total = 11, which is >= desiredTotal.
Same with other integers chosen by the first player, the second player will always win.

class Solution {
    public boolean canIWin(int m, int d) {
        if(m>=d){
            return true;
        }else if(m*(m+1)/2<d)return false;
        int[] b = new int[m+1];
        Map<Integer,Boolean> map = new HashMap<>();

        return q(b,map,d);
    }

    public boolean q(int[] b,Map<Integer,Boolean> m,int d){
        if(d<=0)return false;
        int z =q(b);

        if(!m.containsKey(z)){
            for(int i=1;i<b.length;i++){
                if(b[i]==0){
                    b[i]=1;
                    if(!q(b,m,d-i)){
                        m.put(z,true);
                        b[i]=0;
                        return true;
                    }
                }
            }
            map.put(z,false);
            return false;
        }

        return m.get(z);
    }

    public int q(int[] b){
        int m =0;
        for(int z : b){
            m<<=1;
            m|=z;
        }
        return z;
    }
} 


466. Count The Repetitions
Hard

110

87

Favorite

Share
Define S = [s,n] as the string S which consists of n connected strings s. For example, ["abc", 3] ="abcabcabc".

On the other hand, we define that string s1 can be obtained from string s2 if we can remove some characters from s2 such that it becomes s1. For example, “abc” can be obtained from “abdbec” based on our definition, but it can not be obtained from “acbbe”.

You are given two non-empty strings s1 and s2 (each at most 100 characters long) and two integers 0 ≤ n1 ≤ 106 and 1 ≤ n2 ≤ 106. Now consider the strings S1 and S2, where S1=[s1,n1] and S2=[s2,n2]. Find the maximum integer M such that [S2,M] can be obtained from S1.

Example:

Input:
s1="acb", n1=4
s2="ab", n2=2

Return:
2

class Solution {
    public int getMaxRepetitions(String s1, int n1, String s2, int n2) {
        int i =0;
        int j =1;
        String qq = "";
        int z= -1;
        while(z!=i){
            for(char c : s2.toCharArray()){
                qq=qq+s1;
                int k = s1.indexOf(c,i);
                if(k==-1){
                    k=s1.indexOf(c);
                    if(k==-1){
                        return 0;
                    }
                    j++;
                }
                i=k;
            }

        }
        

        return n1/(n2*j);
    }
}

467. Unique Substrings in Wraparound String
Medium

386

66

Favorite

Share
Consider the string s to be the infinite wraparound string of "abcdefghijklmnopqrstuvwxyz", so s will look like this: "...zabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcd....".

Now we have another string p. Your job is to find out how many unique non-empty substrings of p are present in s. In particular, your input is the string p and you need to output the number of different non-empty substrings of p in the string s.

Note: p consists of only lowercase English letters and the size of p might be over 10000.

Example 1:
Input: "a"
Output: 1

Explanation: Only the substring "a" of string "a" is in the string s.
Example 2:
Input: "cac"
Output: 2
Explanation: There are two substrings "a", "c" of string "cac" in the string s.
Example 3:
Input: "zab"
Output: 6
Explanation: There are six substrings "z", "a", "b", "za", "ab", "zab" of string "zab" in the string s.

class Solution {
    public int findSubstringInWraproundString(String p) {
        int[] q = new int[26];
        int j=1;
        for(int i = 0;i<p.length();i++){

            if(i>0&&(p.charAt(i)-p.charAt(i-1)==1||p.charAt(i-1)-p.charAt(i)==25)){
                j++;
            }else{
                j=1;
            }

            q[p.charAt(i)-'a']=Math.max(j,q[p.charAt(i)-'a']);
        }

        int s = 0;
        for(int i : q){
            s+=i;
        }

        return s;
       

    }
}

468. Validate IP Address
Medium

135

802

Favorite

Share
Write a function to check whether an input string is a valid IPv4 address or IPv6 address or neither.

IPv4 addresses are canonically represented in dot-decimal notation, which consists of four decimal numbers, each ranging from 0 to 255, separated by dots ("."), e.g.,172.16.254.1;

Besides, leading zeros in the IPv4 is invalid. For example, the address 172.16.254.01 is invalid.

IPv6 addresses are represented as eight groups of four hexadecimal digits, each group representing 16 bits. The groups are separated by colons (":"). For example, the address 2001:0db8:85a3:0000:0000:8a2e:0370:7334 is a valid one. Also, we could omit some leading zeros among four hexadecimal digits and some low-case characters in the address to upper-case ones, so 2001:db8:85a3:0:0:8A2E:0370:7334 is also a valid IPv6 address(Omit leading zeros and using upper cases).

However, we don't replace a consecutive group of zero value with a single empty group using two consecutive colons (::) to pursue simplicity. For example, 2001:0db8:85a3::8A2E:0370:7334 is an invalid IPv6 address.

Besides, extra leading zeros in the IPv6 is also invalid. For example, the address 02001:0db8:85a3:0000:0000:8a2e:0370:7334 is invalid.

Note: You may assume there is no extra space or special characters in the input string.

Example 1:
Input: "172.16.254.1"

Output: "IPv4"

Explanation: This is a valid IPv4 address, return "IPv4".
Example 2:
Input: "2001:0db8:85a3:0:0:8A2E:0370:7334"

Output: "IPv6"

Explanation: This is a valid IPv6 address, return "IPv6".
Example 3:
Input: "256.256.256.256"

Output: "Neither"

Explanation: This is neither a IPv4 address nor a IPv6 address.

class Solution {
    public String validIPAddress(String ss) {
         
        if(ss.indexOf(".")>0){
            if(ss.charAt(0)=='.'||ss.charAt(ss.length()-1)=='.')return "Neither";
            String[] qq = ss.split("\\.");
            if(qq.length!=4)return "Neither";

            for(String s : qq){
                if((s.length()>1&&s.charAt(0)=='0')||s.length()==0||s.length()>3)return "Neither";
                int z=0;
                for(char c : s.toCharArray()){
                    int k = c-'0';
                    if(k>9||k<0){
                        return "Neither";
                    }
                    z=z*10+k;
                }  
                if(z>255){
                    return "Neither";
                }  
            }

           
            return "IPv4";
            

        }else if(ss.indexOf(":")>0){
            if(ss.charAt(0)==':'||ss.charAt(ss.length()-1)==':')return "Neither";

            String[] qq = ss.split(":");
            if(qq.length!=8)return "Neither";
            for(String s:qq){
                if(s.length()==0||s.length()>4){
                    return "Neither";
                }

                for(char c : s.toCharArray()){
                    if(c>='0'&&c<='9')continue;
                    if(c>='a'&&c<='f')continue;
                    if(c>='A'&&c<='F')continue;
                    return "Neither";
                }
            }
             return "IPv6";
        }

        return "Neither";
        }
}

Given a function rand7 which generates a uniform random integer in the range 1 to 7, write a function rand10 which generates a uniform random integer in the range 1 to 10.

Do NOT use system's Math.random().

 

Example 1:

Input: 1
Output: [7]
Example 2:

Input: 2
Output: [8,4]
Example 3:

Input: 3
Output: [8,1,10]
 

Note:

rand7 is predefined.
Each testcase has one argument: n, the number of times that rand10 is called.
 

Follow up:

What is the expected value for the number of calls to rand7() function?
Could you minimize the number of calls to rand7()?

/**
 * The rand7() API is already defined in the parent class SolBase.
 * public int rand7();
 * @return a random integer in the range 1 to 7
 */
class Solution extends SolBase {
    int s =40;
    while(s>=40)
    s=7*(rand7()-1)+rand7()-1;
    return s%10+1;
}

472. Concatenated Words
Hard

284

69

Favorite

Share
Given a list of words (without duplicates), please write a program that returns all concatenated words in the given list of words.
A concatenated word is defined as a string that is comprised entirely of at least two shorter words in the given array.

Example:
Input: ["cat","cats","catsdogcats","dog","dogcatsdog","hippopotamuses","rat","ratcatdogcat"]

Output: ["catsdogcats","dogcatsdog","ratcatdogcat"]

Explanation: "catsdogcats" can be concatenated by "cats", "dog" and "cats"; 
 "dogcatsdog" can be concatenated by "dog", "cats" and "dog"; 
"ratcatdogcat" can be concatenated by "rat", "cat", "dog" and "cat".
Note:
The number of elements of the given array will not exceed 10,000
The length sum of elements in the given array will not exceed 600,000.
All the input string will only include lower case letters.
The returned elements order does not matter.

class Solution {
    public List<String> findAllConcatenatedWordsInADict(String[] words) {
          List<String> list = new ArrayList();
          if(word.length<3)return list;
        Set<String> ss = new HashSet<>);
        Arrays.sort(words,(q,w)->{return q.length()-w.length();});
        ss.add(word[0]);
        ss.add(word[1]);
        for(int i = 2;i<words.length;i++){
            String w = words[i];
            int n = w.length();
            boolean[] b = new boolean[n+1];
            b[0]=true;
            for(int z = 1;z<=n;z++){
                for(int x = 0;x<z;x++){
                    if(!b[x])continue;
                    if(ss.contains(w.substring(x,z))){
                        b[z]=true;
                    }
                }
            }
            list.add(w);
            if(b[n]){
                ss.add(w);
                
            }
        }
        return list;
        for(String w : words){
            int n = w.length();
            if(n==0)continue;
            boolean[] b = new boolean[n+1];
            b[0]=true;
             for(int i = 1;i<=n;i++){
                
                for(int j=0;j<i;j++){
                    if(!b[j])continue;
                    String s = w.substring(j,i);
                    if(ss.contains(s)){
                        b[j]=true;

                    }
                }
            }
            if(b[n]){list.add(w);break;}
        }
        return list;

    }
}

Do you still remember how did you solve this problem? https://leetcode.com/problems/word-break/

If you do know one optimized solution for above question is using DP, this problem is just one more step further. We iterate through each word and see if it can be formed by using other words.

Of course it is also obvious that a word can only be formed by words shorter than it. So we can first sort the input by length of each word, and only try to form one word by using words in front of it.

public class Solution {
    public static List<String> findAllConcatenatedWordsInADict(String[] words) {
        List<String> result = new ArrayList<>();
        Set<String> preWords = new HashSet<>();
        Arrays.sort(words, new Comparator<String>() {
            public int compare (String s1, String s2) {
                return s1.length() - s2.length();
            }
        });
        
        for (int i = 0; i < words.length; i++) {
            if (canForm(words[i], preWords)) {
                result.add(words[i]);
            }
            preWords.add(words[i]);
        }
        
        return result;
    }
    
    private static boolean canForm(String word, Set<String> dict) {
        if (dict.isEmpty()) return false;
    boolean[] dp = new boolean[word.length() + 1];
    dp[0] = true;
    for (int i = 1; i <= word.length(); i++) {
        for (int j = 0; j < i; j++) {
        if (!dp[j]) continue;
        if (dict.contains(word.substring(j, i))) {
            dp[i] = true;
            break;
        }
        }
    }
    return dp[word.length()];
    }
}
473. Matchsticks to Square
Medium

344

42

Favorite

Share
Remember the story of Little Match Girl? By now, you know exactly what matchsticks the little match girl has, please find out a way you can make one square by using up all those matchsticks. You should not break any stick, but you can link them up, and each matchstick must be used exactly one time.

Your input will be several matchsticks the girl has, represented with their stick length. Your output will either be true or false, to represent whether you could make one square using all the matchsticks the little match girl has.

Example 1:
Input: [1,1,2,2,2]
Output: true

Explanation: You can form a square with length 2, one side of the square came two sticks with length 1.
Example 2:
Input: [3,3,3,3,4]
Output: false

Explanation: You cannot find a way to form a square with all the matchsticks.
Note:
The length sum of the given matchsticks is in the range of 0 to 10^9.
The length of the given matchstick array will not exceed 15.

class Solution {
    public boolean makesquare(int[] nums) {
         if(nums.length<4)return false;
        int sum = 0;
       
        for(int i : nums){
            sum+=i;
        }

        if(sum%4!=0)return false;
        int s = sum/4;
      
        Arrays.sort(nums);
        return q(nums,nums.length-1,new int[4],s);

    }

    public boolean q(int[] nums,int t,int[] nn,int s){
        if(t==0){
            return nn[0]==s&&nn[1]==s&&nn[2]==s;
        }

        for(int i =0 ;i<4;i++){
            if(nn[i]+nums[t]>s)continue;
            nn[i]+=nums[t];
            if(q(nums,t-1,nn,s))return true;
            nn[i]-=nums[t];
        }

        return false;
    }
}

class Solution {
    public boolean makesquare(int[] nums) {
        if(nums.length<4)return false;
         long sum = 0L;
        List<Long> list = new ArrayList<>();
        for(int i : nums){
            list.add((long)i);
            sum+=i;
        }

        if(sum%4!=0L)return false;
        long s = sum/4;
        for(int i = 0;i<4;i++){
            if(!q(list,s)){
                return false;
            }
        }

        return list.size()==0;


    }

    public boolean q(List<Long> list,long s){
        
        if(s==0)return true;
        if(s<0)return false;
        if(list.size()==0)return false;
        
        long q=list.remove(0);
        boolean b = q(list,s-q);
        if(!b)list.add(q);
        return b;
    }
}

474. Ones and Zeroes
Medium

598

145

Favorite

Share
In the computer world, use restricted resource you have to generate maximum benefit is what we always want to pursue.

For now, suppose you are a dominator of m 0s and n 1s respectively. On the other hand, there is an array with strings consisting of only 0s and 1s.

Now your task is to find the maximum number of strings that you can form with given m 0s and n 1s. Each 0 and 1 can be used at most once.

Note:

The given numbers of 0s and 1s will both not exceed 100
The size of given string array won't exceed 600.
 

Example 1:

Input: Array = {"10", "0001", "111001", "1", "0"}, m = 5, n = 3
Output: 4

Explanation: This are totally 4 strings can be formed by the using of 5 0s and 3 1s, which are “10,”0001”,”1”,”0”
 

Example 2:

Input: Array = {"10", "0", "1"}, m = 1, n = 1
Output: 2

Explanation: You could form "10", but then you'd have nothing left. Better form "0" and "1".

class Solution {
    public int findMaxForm(String[] ss, int m, int n) {
         int[][] ii =new int[m+1][n+1];
        for(String s : ss){
            int q = 0;
            int w = 0;
            for(char c : s.toCharArray()){
                if(c=='0')q++;
                else w++;
            }

            for(int i = m;i>=q;i--){
                for(int j = n;j>=w;j--){
                    ii[i][j]=Math.max(ii[i][j],ii[i-q][j-w]+1);
                }
            }
        }
        return ii[m][n];
    }
}

475. Heaters
Easy

517

536

Favorite

Share
Winter is coming! Your first job during the contest is to design a standard heater with fixed warm radius to warm all the houses.

Now, you are given positions of houses and heaters on a horizontal line, find out minimum radius of heaters so that all houses could be covered by those heaters.

So, your input will be the positions of houses and heaters seperately, and your expected output will be the minimum radius standard of heaters.

Note:

Numbers of houses and heaters you are given are non-negative and will not exceed 25000.
Positions of houses and heaters you are given are non-negative and will not exceed 10^9.
As long as a house is in the heaters' warm radius range, it can be warmed.
All the heaters follow your radius standard and the warm radius will the same.
 

Example 1:

Input: [1,2,3],[2]
Output: 1
Explanation: The only heater was placed in the position 2, and if we use the radius 1 standard, then all the houses can be warmed.
 

Example 2:

Input: [1,2,3,4],[1,4]
Output: 1
Explanation: The two heater was placed in the position 1 and 4. We need to use radius 1 standard, then all the houses can be warmed.

class Solution {
    public int findRadius(int[] z, int[] h) {
        Arrays.sort(houses);
        Arrays.sort(h);

         int j = 0,s=0;
        for(int i = 0;i<z.length;i++){
            
            while(j<h.length-1){
                if(Math.abs(h[j]-z[i])<Math.abs(h[j+1]-z[i])){
                    break;
                }
                j++;
            }
            s=Math.max(Math.abs(h[j]-z[i]),s);

        }
        return s;
    }
}

476. Number Complement
Easy

579

75

Favorite

Share
Given a positive integer, output its complement number. The complement strategy is to flip the bits of its binary representation.

Note:
The given integer is guaranteed to fit within the range of a 32-bit signed integer.
You could assume no leading zero bit in the integer’s binary representation.
Example 1:
Input: 5
Output: 2
Explanation: The binary representation of 5 is 101 (no leading zero bits), and its complement is 010. So you need to output 2.
Example 2:
Input: 1
Output: 0
Explanation: The binary representation of 1 is 1 (no leading zero bits), and its complement is 0. So you need to output 0.

class Solution {
    public int findComplement(int num) {
        int q = 1;
        while(q<num){
            q=(q<<1)|1;
        }
        return num^q;
        
    }
}

477. Total Hamming Distance
Medium

580

41

Favorite

Share
The Hamming distance between two integers is the number of positions at which the corresponding bits are different.

Now your job is to find the total Hamming distance between all pairs of the given numbers.

Example:
Input: 4, 14, 2

Output: 6

Explanation: In binary representation, the 4 is 0100, 14 is 1110, and 2 is 0010 (just
showing the four bits relevant in this case). So the answer will be:
HammingDistance(4, 14) + HammingDistance(4, 2) + HammingDistance(14, 2) = 2 + 2 + 2 = 6.
Note:
Elements of the given array are in the range of 0 to 10^9
Length of the array will not exceed 10^4.

class Solution {
    public int totalHammingDistance(int[] nums) {
        int s = 0;
        for(int i =0;i<32;i++){
            int q = 0;
            for(int n : nums){
                q+=((n>>1)&1);
                
            }
            s+=q*(num.length-q);
        }
        return s;
        int[] q = new int[32];
        int[] w = new int[32];
        for(int n : nums){
            int i = 0;
            while(i!=32){
               if((n&1)==1){
                    q[i]++;
               }else{
                    w[i]++;
               }
                n>>=1;
               i++;
            }
        }

        int t = 0; 
        for(int i = 0 ;i<32;i++){
            t+=q[i]*w[i];
        }
        return t;

    }
}

478. Generate Random Point in a Circle
Medium

106

171

Favorite

Share
Given the radius and x-y positions of the center of a circle, write a function randPoint which generates a uniform random point in the circle.

Note:

input and output values are in floating-point.
radius and x-y position of the center of the circle is passed into the class constructor.
a point on the circumference of the circle is considered to be in the circle.
randPoint returns a size 2 array containing x-position and y-position of the random point, in that order.
Example 1:

Input: 
["Solution","randPoint","randPoint","randPoint"]
[[1,0,0],[],[],[]]
Output: [null,[-0.72939,-0.65505],[-0.78502,-0.28626],[-0.83119,-0.19803]]
Example 2:

Input: 
["Solution","randPoint","randPoint","randPoint"]
[[10,5,-7.5],[],[],[]]
Output: [null,[11.52438,-8.33273],[2.46992,-16.21705],[11.13430,-12.42337]]
Explanation of Input Syntax:

The input is two lists: the subroutines called and their arguments. Solution's constructor has three arguments, the radius, x-position of the center, and y-position of the center of the circle. randPoint has no arguments. Arguments are always wrapped with a list, even if there aren't any.

class Solution {

    
    double r ;
    double x;
    double y;
    public Solution(double radius, double x_center, double y_center) {
        r = radius;
        x=x_center;
        y=y_center;
    }
    

    double[] dd = new double[2];
    public double[] randPoint() {
       int l  = Math.sqrt(Math.rand())*r;
       int d = Math.rand()*2*Math.PI;
       dd[0]=x+l*Math.cos(d);
       dd[1]=y+l*Math.sin(d);
       return dd;
    }
}

/**
 * Your Solution object will be instantiated and called as such:
 * Solution obj = new Solution(radius, x_center, y_center);
 * double[] param_1 = obj.randPoint();
 */

 479. Largest Palindrome Product
Hard

73

1240

Favorite

Share
Find the largest palindrome made from the product of two n-digit numbers.

Since the result could be very large, you should return the largest palindrome mod 1337.

 

Example:

Input: 2

Output: 987

Explanation: 99 x 91 = 9009, 9009 % 1337 = 987

 

Note:

The range of n is [1,8].

class Solution {

    public int largestPalindrome(int n) {
        if(n==1)return 9;
        long max = Math.pow(10,n)-1,min = max/10+1;

        long q = Math.pow(10,n);
        while(max>min){
            if(z(max*(max-1),q)){
                return max
            }
        }
        
    }

    public boolean z(long z,long x){
        long q = z/x;
        long w = z%x;

        long t = 0;
        while(w!=0){

            t=t*10+w%10;
            w/=10;
        }
        return q==t; 
    }
    public int largestPalindrome(int n) {
        if(n==1)return 9;
        long max = Math.pow(10,n)-1,min = max/10;

        long m = max*max;
        m=m/Math.pow(10,n);

        boolean b = false;

        long s=0;
        while(!b){
            long s = z(m);

            long i = max;
            for(;i>min;i-- ){
                if(s/i>max){
                    break;
                }

                if(s%i==0){
                    b=true;
                    break;
                }

            }

            m--;



        }

        return (int)(s%1337);
        
    }


    public long z(long z){
        long k = z;
        while(z!=0){
            k=k*10+z%10;
            z/=10;
        }
        return k;
    }
}


480. Sliding Window Median
Hard

480

52

Favorite

Share
Median is the middle value in an ordered integer list. If the size of the list is even, there is no middle value. So the median is the mean of the two middle value.

Examples: 
[2,3,4] , the median is 3

[2,3], the median is (2 + 3) / 2 = 2.5

Given an array nums, there is a sliding window of size k which is moving from the very left of the array to the very right. You can only see the k numbers in the window. Each time the sliding window moves right by one position. Your job is to output the median array for each window in the original array.

For example,
Given nums = [1,3,-1,-3,5,3,6,7], and k = 3.

Window position                Median
---------------               -----
[1  3  -1] -3  5  3  6  7       1
 1 [3  -1  -3] 5  3  6  7       -1
 1  3 [-1  -3  5] 3  6  7       -1
 1  3  -1 [-3  5  3] 6  7       3
 1  3  -1  -3 [5  3  6] 7       5
 1  3  -1  -3  5 [3  6  7]      6
Therefore, return the median sliding window as [1,-1,-1,3,5,6].

Note: 
You may assume k is always valid, ie: k is always smaller than input array's size for non-empty array.

class Solution {
    public double[] medianSlidingWindow(int[] nums, int k) {
         JJJ j = new JJJ();
       
       int q = 0;
       while(q!=k){
            j.a(nums[q]);
            q++;
       }
       double[] dd = new double[nums.length+1-k];
       for(int i = k;i<nums.length;i++){
            dd[i-k]=j.g();
            j.r(nums[i-k]);
            j.a(nums[i]);
       }
        
        dd[nums.length+1-k]=j.g();
        return dd;
    }


    class JJJ{
        PriorityQueue<Integer> m = new PriorityQueue();
        PriorityQueue<Integer> s = new PriorityQueue(Collections.reverseOrder());

        public void a(int num){
            m.add(num);
            s.add(m.poll());
            if(s.size()>m.size()){
                m.add(s.poll()); 
            }

            if(m.size()-s.size()>1){
                s.add(m.poll());
            }
        }

[1,3,-1,-3,5,3,6,7]
3
        public double g(){
            if(m.size()>s.size())return (double)m.peek();
            return (m.peek()+s.peek())/2d;
        }

        public void r(int num){
            if(num<g()){
                s.remove(num);
            }else{
                m.remove(num);
            }
            if(s.size()>m.size()){
                m.add(s.poll());
            }

            if(m.size()-s.size()>1){
                s.add(m.poll());
            }
        }
    }


}
482. License Key Formatting
Easy

331

565

Favorite

Share
You are given a license key represented as a string S which consists only alphanumeric character and dashes. The string is separated into N+1 groups by N dashes.

Given a number K, we would want to reformat the strings such that each group contains exactly K characters, except for the first group which could be shorter than K, but still must contain at least one character. Furthermore, there must be a dash inserted between two groups and all lowercase letters should be converted to uppercase.

Given a non-empty string S and a number K, format the string according to the rules described above.

Example 1:
Input: S = "5F3Z-2e-9-w", K = 4

Output: "5F3Z-2E9W"

Explanation: The string S has been split into two parts, each part has 4 characters.
Note that the two extra dashes are not needed and can be removed.
Example 2:
Input: S = "2-5g-3-J", K = 2

Output: "2-5G-3J"

Explanation: The string S has been split into three parts, each part has 2 characters except the first part as it could be shorter as mentioned above.
Note:
The length of string S will not exceed 12,000, and K is a positive integer.
String S consists only of alphanumerical characters (a-z and/or A-Z and/or 0-9) and dashes(-).
String S is non-empty.
class Solution {
    public String licenseKeyFormatting(String s, int k) {

        int j = 0;
        StringBuilder sb = new StringBuilder();
        for(int i = s.length()-1;i>-1;i--){
            char c = s.charAt(i);
            if(c=='-'){
                continue;
            }
            j++;

            if(j==1&&sb.length()>0){
             sb.append('-');
            }
            if(c>='a'&&c<='z')c-=32;
            sb.append(c);
            if(j==k){
               
                j=0;
            }

        }
        return sb.reverse().toString();
        
    }
}

s=s.replaceAll("-","");
        if(s.length<k)return s;
        int l = 0;
        StringBuilder sb = new StringBuilder();
        if(s.length%k==0){
            l=2;
            sb.append(s.charAt(0)).append("-");
        }
        int j = 0;
       
        for(int i = s.length()-1;i>-1;i--){
            j++;

            
            if(j==k){
                sb.insert(0,'-');
                j=0;
            }
            sb.insert(0,s.charAt(i));

        }
        return sb.toString();
485. Max Consecutive Ones
Easy

409

328

Favorite

Share
Given a binary array, find the maximum number of consecutive 1s in this array.

Example 1:
Input: [1,1,0,1,1,1]
Output: 3
Explanation: The first two digits or the last three digits are consecutive 1s.
    The maximum number of consecutive 1s is 3.
Note:

The input array will only contain 0 and 1.
The length of input array is a positive integer and will not exceed 10,000

class Solution {
    public int findMaxConsecutiveOnes(int[] nums) {
        int q = 0;
        int z = 0;
        for(int i : nums){
            if(i==0){
                q=Math.max(q,z);
                z=0;
            }else{
                z++;
            }
        }
        return Math.max(q,z);
    }
}

Predict the Winner
Medium

1103

72

Favorite

Share
Given an array of scores that are non-negative integers. Player 1 picks one of the numbers from either end of the array followed by the player 2 and then player 1 and so on. Each time a player picks a number, that number will not be available for the next player. This continues until all the scores have been chosen. The player with the maximum score wins.

Given an array of scores, predict whether player 1 is the winner. You can assume each player plays to maximize his score.

Example 1:
Input: [1, 5, 2]
Output: False
Explanation: Initially, player 1 can choose between 1 and 2. 
If he chooses 2 (or 1), then player 2 can choose from 1 (or 2) and 5. If player 2 chooses 5, then player 1 will be left with 1 (or 2). 
So, final score of player 1 is 1 + 2 = 3, and player 2 is 5. 
Hence, player 1 will never be the winner and you need to return False.
Example 2:
Input: [1, 5, 233, 7]
Output: True
Explanation: Player 1 first chooses 1. Then player 2 have to choose between 5 and 7. No matter which number player 2 choose, player 1 can choose 233.
Finally, player 1 has more score (234) than player 2 (12), so you need to return True representing player1 can win.
Note:
1 <= length of the array <= 20.
Any scores in the given array are non-negative integers and will not exceed 10,000,000.
If the scores of both players are equal, then player 1 is still the winner.

int[][] qq = new int[nums.length][nums.length];
for(int i = 0;i<nums.length;i++)qq[i][i]=nums[i];
for(int i =1;i<qq.length;i++){
    for(int j = 0;j<i;j++){
        int k = j+i;
        qq[j][k]=Math.max(nums[j]-q[j+1][k],num[j]-qq[j][k-1]);
    }
}
return qq[0][nums.length-1];
class Solution {
    public boolean PredictTheWinner(int[] nums) {
        return qwe(nums,0,0,0,nums.length-1,true);
    }

    void qwe(int[] nums,int ll,int ss,int l,int s,boolean b){
        if(s<l){
            return ll>=ss;
        }

        if(b){
            return qwe(nums,ll+nums[l],ss,l+1,s,false)||qwe(nums,ll+nums[s],ss,l,s-1,false);

        }else{
            return !qwe(nums,ll,ss+nums[l],l+1,s,true)&&!qwe(nums,ll,ss+nums[s],l,s-1,true);
        }
    }
}



The dp[i][j] saves how much more scores that the first-in-action player will get from i to j than the second player. First-in-action means whomever moves first. You can still make the code even shorter but I think it looks clean in this way.

public boolean PredictTheWinner(int[] nums) {
    int n = nums.length;
    int[][] dp = new int[n][n];
    for (int i = 0; i < n; i++) { dp[i][i] = nums[i]; }
    for (int len = 1; len < n; len++) {
        for (int i = 0; i < n - len; i++) {
            int j = i + len;
            dp[i][j] = Math.max(nums[i] - dp[i + 1][j], nums[j] - dp[i][j - 1]);
        }
    }
    return dp[0][n - 1] >= 0;
}
Here is the code for O(N) space complexity:


public boolean PredictTheWinner(int[] nums) {
    if (nums == null) { return true; }
    int n = nums.length;
    if ((n & 1) == 0) { return true; } // Improved with hot13399's comment.
    int[] dp = new int[n];
    for (int i = n - 1; i >= 0; i--) {
        for (int j = i; j < n; j++) {
            if (i == j) {
                dp[i] = nums[i];
            } else {
                dp[j] = Math.max(nums[i] - dp[j], nums[j] - dp[j - 1]);
            }
        }
    }
    return dp[n - 1] >= 0;
}

Edit : Since I have some time now, I will explain how I come up with this solution step by step:

1, The first step is to break the question into the sub-problems that we can program. From the question, the winning goal is that "The player with the maximum score wins". So one way to approach it is that we may want to find a way to maximize player 1's sum and check if it is greater than player 2's sum (or more than half of the sum of all numbers). Another way, after noting that the sum of all numbers is fixed, I realized that it doesn't matter how much player 1's total sum is as long as the sum is no less than player 2's sum. No matter how, I think we can easily recognize that it is a recursive problem where we may use the status on one step to calculate the answer for the next step. It is a common way to solve game problems. So we may start with using a brutal force recursive method to solve this one.

2, However, we always want to do better than brutal force. We may easily notice that there will be lots of redundant calculation. For example, "player 1 picks left, then player 2 picks left, then player 1 picks right, then player 2 picks right" will end up the same as "player 1 picks right, then player 2 picks right, then player 1 picks left, then player 2 picks left". So, we may want to use dynamic programming to save intermediate states.

3, I think it will be easy to think about using a two dimensional array dp[i][j] to save all the intermediate states. From step 1, we may see at least two ways of doing it. It just turned out that if we choose to save how much more scores that the first-in-action player will earn from position i to j in the array (as I did), the code will be better in a couple of ways.

4, After we decide that dp[i][j] saves how much more scores that the first-in-action player will get from i to j than the second player, the next step is how we update the dp table from one state to the next. Going back to the question, each player can pick one number either from the left or the right end of the array. Suppose they are picking up numbers from position i to j in the array and it is player A's turn to pick the number now. If player A picks position i, player A will earn nums[i] score instantly. Then player B will choose from i + 1 to j. Please note that dp[i + 1][j] already saves how much more score that the first-in-action player will get from i + 1 to j than the second player. So it means that player B will eventually earn dp[i + 1][j] more score from i + 1 to j than player A. So if player A picks position i, eventually player A will get nums[i] - dp[i + 1][j] more score than player B after they pick up all numbers. Similarly, if player A picks position j, player A will earn nums[j] - dp[i][j - 1] more score than player B after they pick up all numbers. Since A is smart, A will always choose the max in those two options, so:
dp[i][j] = Math.max(nums[i] - dp[i + 1][j], nums[j] - dp[i][j - 1]);

5, Now we have the recursive formula, the next step is to decide where it all starts. This step is easy because we can easily recognize that we can start from dp[i][i], where dp[i][i] = nums[i]. Then the process becomes a very commonly seen process to update the dp table. I promise that this is a very useful process. Everyone who is preparing for interviews should get comfortable with this process:
Using a 5 x 5 dp table as an example, where i is the row number and j is the column number. Each dp[i][j] corresponds to a block at row i, column j on the table. We may start from filling dp[i][i], which are all the diagonal blocks. I marked them as 1. Then we can see that each dp[i][j] depends only on dp[i + 1][j] and dp[i][j - 1]. On the table, it means each block (i, j) only depends on the block to its left (i, j - 1) and to its down (i + 1, j). So after filling all the blocks marked as 1, we can start to calculate those blocks marked as 2. After that, all blocks marked as 3 and so on.
0_1488092542752_dp.jpg
So in my code, I always use len to denote how far the block is away from the diagonal. So len ranges from 1 to n - 1. Remember this is the outer loop. The inner loop is all valid i positions. After filling all the upper side of the table, we will get our answer at dp[0][n - 1] (marked as 5). This is the end of my code.

However, if you are interviewing with a good company, they may challenge you to further improve your code, probably in the aspect of space complexity. So far, we are using a n x n matrix so the space complexity is O(n^2). It actually can be improved to O(n). That can be done by changing our way of filling the table. We may use only one dimensional dp[i] and we start to fill the table at the bottom right corner where dp[4] = nums[4]. On the next step, we start to fill the second to the last line, where it starts from dp[3] = nums[3]. Then dp[4] = Math.max(nums[4] - dp[3], nums[3] - dp[4]). Then we fill the third to the last line where dp[2] = nums[2] and so on... Eventually after we fill the first line and after the filling, dp[4] will be the answer.

On a related note, whenever we do sum, subtract, multiply or divide of integers, we might need to think about overflow. It doesn't seem to be a point to check for this question. However, we may want to consider using long instead of int for some cases. Further, in my way of code dp[i][j] roughly varies around zero or at least it doesn't always increases with approaching the upper right corner. So it will be less likely to overflow.

488. Zuma Game
Hard

151

146

Favorite

Share
Think about Zuma Game. You have a row of balls on the table, colored red(R), yellow(Y), blue(B), green(G), and white(W). You also have several balls in your hand.

Each time, you may choose a ball in your hand, and insert it into the row (including the leftmost place and rightmost place). Then, if there is a group of 3 or more balls in the same color touching, remove these balls. Keep doing this until no more balls can be removed.

Find the minimal balls you have to insert to remove all the balls on the table. If you cannot remove all the balls, output -1.

Examples:

Input: "WRRBBW", "RB"
Output: -1
Explanation: WRRBBW -> WRR[R]BBW -> WBBW -> WBB[B]W -> WW

Input: "WWRRBBWW", "WRBRW"
Output: 2
Explanation: WWRRBBWW -> WWRR[R]BBWW -> WWBBWW -> WWBB[B]WW -> WWWW -> empty

Input:"G", "GGGGG"
Output: 2
Explanation: G -> G[G] -> GG[G] -> empty 

Input: "RBYYBBRRB", "YRBGB"
Output: 3
Explanation: RBYYBBRRB -> RBYY[Y]BBRRB -> RBBBRRB -> RRRB -> B -> B[B] -> BB[B] -> empty 

Note:
You may assume that the initial row of balls on the table won’t have any 3 or more consecutive balls with the same color.
The number of balls on the table won't exceed 20, and the string represents these balls is called "board" in the input.
The number of balls in your hand won't exceed 5, and the string represents these balls is called "hand" in the input.
Both input strings will be non-empty and only contain characters 'R','Y','B','G','W'.


491. Increasing Subsequences
Medium

480

90

Favorite

Share
Given an integer array, your task is to find all the different possible increasing subsequences of the given array, and the length of an increasing subsequence should be at least 2.

 

Example:

Input: [4, 6, 7, 7]
Output: [[4, 6], [4, 7], [4, 6, 7], [4, 6, 7, 7], [6, 7], [6, 7, 7], [7,7], [4,7,7]]
 

Note:

The length of the given array will not exceed 15.
The range of integer in the given array is [-100,100].
The given array may contain duplicates, and two equal integers should also be considered as a special case of increasing sequence.
public List<List<Integer>> q(int[] nums){
    List<List<Integer>> list = new ArrayList<>();
    q(new ArrayList<>(),nums,0,list);
    return list;

    List<List<Integer>> list = new ArrayList<>();
    
        q(list,nums,0);
        for(int i =0;i<list.size();i++){
            if(list.get(i).size()<2){
                list.remove(i);
                i--;
            }
        }
    return list;
}

public void q(List<Integer> array,int j,int[] nums,List<List<Integer>> list){
    if(array.size()>1)list.add(new ArrayList<>(array));
    Set<Integer> set = new HashSet<>();
    for(int i =j;i<nums.length;j++){
        if(set.contains(nums[i]))continue;
        if(array.size()==0||array.get(array.size()-1)<=nums[i]){
            set.add(nums[i]);
            array.add(nums[i]);
            q(array,i+1,nums,list);
            array.remove(array.size()-1);
        }
    }
}

public void q(List<List<Integer>> list,int[] nums,int i){
   if(i==nums.length)return ;

   int k = list.size();
   int d = 1;
   while(i+d<nums.length&&nums[i]==nums[i+d]){
        d++;
   }

   List<Integer> q = new ArrayList<>();
   for(int j =-1;j<k;){
        for(int f=0;f<d;f++){
            
            q.add(nums[i]);
            list.add(q);
            q=new ArrayList<>(q); 
        }
        j++;
        if(list.get(j).size()>0&&list.get(j).get(list.get(j).size()-1)>nums[i])
            break;
        q = new ArrayList<>(list.get(j));
        
   }
   q(list,nums,i+d);
}
[1,2,3,4,5,6,7,8,9,10,1,1,1,1,1]

public class Solution {
    public List<List<Integer>> findSubsequences(int[] nums) {
        List<List<Integer>> res = new LinkedList<>();
        helper(new LinkedList<Integer>(), 0, nums, res);
        return res; 
    }
    private void helper(LinkedList<Integer> list, int index, int[] nums, List<List<Integer>> res){
        if(list.size()>1) res.add(new LinkedList<Integer>(list));
        Set<Integer> used = new HashSet<>();
        for(int i = index; i<nums.length; i++){
            if(used.contains(nums[i])) continue;
            if(list.size()==0 || nums[i]>=list.peekLast()){
                used.add(nums[i]);
                list.add(nums[i]); 
                helper(list, i+1, nums, res);
                list.remove(list.size()-1);
            }
        }
    }
}
Pretty straightforward. Maybe one thing is: while nums is not necessarily sorted but we have to skip duplicates in each recursion, so we use a hash set to record what we have used in this particular recursion.

492. Construct the Rectangle
Easy

146

224

Favorite

Share
For a web developer, it is very important to know how to design a web page's size. So, given a specific rectangular web page’s area, your job by now is to design a rectangular web page, whose length L and width W satisfy the following requirements:

1. The area of the rectangular web page you designed must equal to the given target area.

2. The width W should not be larger than the length L, which means L >= W.

3. The difference between length L and width W should be as small as possible.
You need to output the length L and the width W of the web page you designed in sequence.
Example:
Input: 4
Output: [2, 2]
Explanation: The target area is 4, and all the possible ways to construct it are [1,4], [2,2], [4,1]. 
But according to requirement 2, [1,4] is illegal; according to requirement 3,  [4,1] is not optimal compared to [2,2]. So the length L is 2, and the width W is 2.
Note:
The given area won't exceed 10,000,000 and is a positive integer
The web page's width and length you designed must be positive integers.

class Solution {
    public int[] constructRectangle(int area) {
        int z = (int)Math.sqrt(area);
        int l = area/z;
        while(l*z!=area){
            z--;
            l=area/z;
        }
        return new int[]{l,z};
        int z = (int)Math.sqrt(area);

        if(area/z==z){
            return new int[]{z,z};
        }

        while(true){
            int q = area/z;
            

            if(q>z){
                if(area%z==0){
                    return new int[]{q,z};
                }
                z++;
            }else{
                 if(area%z==0){
                    return new int[]{z,q};
                }
                z--;
            }
        }

    }
}


493. Reverse Pairs
Hard

606

90

Favorite

Share
Given an array nums, we call (i, j) an important reverse pair if i < j and nums[i] > 2*nums[j].

You need to return the number of important reverse pairs in the given array.

Example1:

Input: [1,3,2,3,1]
Output: 2
Example2:

Input: [2,4,3,5,1]
Output: 3
Note:
The length of the given array will not exceed 50,000.
All the numbers in the input array are in the range of 32-bit integer.

class Solution {
    public int reversePairs(int[] nums) {
        int[][] qq = new int[nums.length][nums.length];
        int q = 0;
        for(int i = 0;i<nums.length;i++){
            for(int j = i+1;j<nums.length;j++){
                if(nums[i]>2l*nums[j]){
                    q++;
                }
            }
        }
        return q;
    }
}

494. Target Sum
Medium

1630

78

Favorite

Share
You are given a list of non-negative integers, a1, a2, ..., an, and a target, S. Now you have 2 symbols + and -. For each integer, you should choose one from + and - as its new symbol.

Find out how many ways to assign symbols to make sum of integers equal to target S.

Example 1:
Input: nums is [1, 1, 1, 1, 1], S is 3. 
Output: 5
Explanation: 

-1+1+1+1+1 = 3
+1-1+1+1+1 = 3
+1+1-1+1+1 = 3
+1+1+1-1+1 = 3
+1+1+1+1-1 = 3

There are 5 ways to assign symbols to make the sum of nums be target 3.
Note:
The length of the given array is positive and will not exceed 20.
The sum of elements in the given array will not exceed 1000.
Your output answer is guaranteed to be fitted in a 32-bit integer.
The recursive solution is very slow, because its runtime is exponential

The original problem statement is equivalent to:
Find a subset of nums that need to be positive, and the rest of them negative, such that the sum is equal to target

Let P be the positive subset and N be the negative subset
For example:
Given nums = [1, 2, 3, 4, 5] and target = 3 then one possible solution is +1-2+3-4+5 = 3
Here positive subset is P = [1, 3, 5] and negative subset is N = [2, 4]

Then let's see how this can be converted to a subset sum problem:

                  sum(P) - sum(N) = target
sum(P) + sum(N) + sum(P) - sum(N) = target + sum(P) + sum(N)
                       2 * sum(P) = target + sum(nums)
So the original problem has been converted to a subset sum problem as follows:
Find a subset P of nums such that sum(P) = (target + sum(nums)) / 2

Note that the above formula has proved that target + sum(nums) must be even
We can use that fact to quickly identify inputs that do not have a solution (Thanks to @BrunoDeNadaiSarnaglia for the suggestion)
For detailed explanation on how to solve subset sum problem, you may refer to Partition Equal Subset Sum

Here is Java solution (15 ms)

    public int findTargetSumWays(int[] nums, int s) {
        int sum = 0;
        for (int n : nums)
            sum += n;
        return sum < s || (s + sum) % 2 > 0 ? 0 : subsetSum(nums, (s + sum) >>> 1); 
    }   

    public int subsetSum(int[] nums, int s) {
        int[] dp = new int[s + 1]; 
        dp[0] = 1;
        for (int n : nums)
            for (int i = s; i >= n; i--)
                dp[i] += dp[i - n]; 
        return dp[s];
    } 
Here is C++ solution (3 ms)

class Solution {
public:
    int findTargetSumWays(vector<int>& nums, int s) {
        int sum = accumulate(nums.begin(), nums.end(), 0);
        return sum < s || (s + sum) & 1 ? 0 : subsetSum(nums, (s + sum) >> 1); 
    }   

    int subsetSum(vector<int>& nums, int s) {
        int dp[s + 1] = { 0 };
        dp[0] = 1;
        for (int n : nums)
            for (int i = s; i >= n; i--)
                dp[i] += dp[i - n];
        return dp[s];
    }
};
class Solution {
    public int findTargetSumWays(int[] nums, int S) {
        int sum = 0;
        for(int n : nums){
            sum+=n;
        }

        if(sum<S||((sum+S)&1)==1)return 0;
        return q(nums,(sum+S)/2,0);
       
    }

    public int q(int[] nums,int s,int i){
        if(s<0)return 0;

         if(i+1>nums.length){
            if(s==0)return 1;
            else return 0;
         }
        return q(nums,s-nums[i],i+1)+q(nums,s,i+1);

    }

    public int q(int[] nums,int s,int i){
        if(i==nums.length){
            if(s==0){
                return 1;
            }else{
                return 0;
            }
            
        }

        return q(nums,s-nums[i],i+1)+q(nums,s+nums[i],i+1);
    }
}

495. Teemo Attacking
Medium

271

572

Favorite

Share
In LOL world, there is a hero called Teemo and his attacking can make his enemy Ashe be in poisoned condition. Now, given the Teemo's attacking ascending time series towards Ashe and the poisoning time duration per Teemo's attacking, you need to output the total time that Ashe is in poisoned condition.

You may assume that Teemo attacks at the very beginning of a specific time point, and makes Ashe be in poisoned condition immediately.

Example 1:

Input: [1,4], 2
Output: 4
Explanation: At time point 1, Teemo starts attacking Ashe and makes Ashe be poisoned immediately. 
This poisoned status will last 2 seconds until the end of time point 2. 
And at time point 4, Teemo attacks Ashe again, and causes Ashe to be in poisoned status for another 2 seconds. 
So you finally need to output 4.
 

Example 2:

Input: [1,2], 2
Output: 3
Explanation: At time point 1, Teemo starts attacking Ashe and makes Ashe be poisoned. 
This poisoned status will last 2 seconds until the end of time point 2. 
However, at the beginning of time point 2, Teemo attacks Ashe again who is already in poisoned status. 
Since the poisoned status won't add up together, though the second poisoning attack will still work at time point 2, it will stop at the end of time point 3. 
So you finally need to output 3.
 

Note:

You may assume the length of given time series array won't exceed 10000.
You may assume the numbers in the Teemo's attacking time series and his poisoning time duration per attacking are non-negative integers, which won't exceed 10,000,000.

class Solution {
    public int findPoisonedDuration(int[] q, int d) {
        if(q.length==0)return 0;
        int t= 0;
        for(int i = 1 ;i<q.length;i++){
            if(q[i]>q[i-1]+d){
                t+=d;
            }else{
                t+=q[i]-q[i-1];
            }
        }
        return t+d;
        int q = -10000;
        for(int n : timeSeries){
            if(q+d>n){
                t+=n-q;
            }else{
                t+=d;
            }
            q=n;

        }
        t+=q==-1?0:d;
        return t;
    }
}

496. Next Greater Element I
Easy

948

1528

Favorite

Share
You are given two arrays (without duplicates) nums1 and nums2 where nums1’s elements are subset of nums2. Find all the next greater numbers for nums1's elements in the corresponding places of nums2.

The Next Greater Number of a number x in nums1 is the first greater number to its right in nums2. If it does not exist, output -1 for this number.

Example 1:
Input: nums1 = [4,1,2], nums2 = [1,3,4,2].
Output: [-1,3,-1]
Explanation:
    For number 4 in the first array, you cannot find the next greater number for it in the second array, so output -1.
    For number 1 in the first array, the next greater number for it in the second array is 3.
    For number 2 in the first array, there is no next greater number for it in the second array, so output -1.
Example 2:
Input: nums1 = [2,4], nums2 = [1,2,3,4].
Output: [3,-1]
Explanation:
    For number 2 in the first array, the next greater number for it in the second array is 3.
    For number 4 in the first array, there is no next greater number for it in the second array, so output -1.
Note:
All elements in nums1 and nums2 are unique.
The length of both nums1 and nums2 would not exceed 1000.

class Solution {
    public int[] nextGreaterElement(int[] nums1, int[] nums2) {
        int[] ii = new int[nums1.length];
        int[] qq = new int[nums2.length];
        for(int i = 0;i<qq.length;i++){
            qq[i]=-1;
            for(int j=i+1;j<qq.length;j++){
                if(nums2[i]<nums2[j]){
                    qq[i]=nums2[j];
                    break;
                }
            }

        }
        for(int i = 0;i<ii.length;i++){
            for(int j = 0;j<qq.length;j++){
               if(nums1[i]==nums2[j]){
                    ii[i]=qq[j];
                    break;
               }
            }
        }
        return ii;
    }
}

 HashMap<Integer, Integer> nextGreater = new HashMap<Integer, Integer>();
        Stack<Integer> stack = new Stack<Integer>();
        for(int num : nums2) {
            while(!stack.isEmpty() && stack.peek() < num)
                nextGreater.put(stack.pop(), num);
            stack.push(num);
        }
        for(int i=0; i<nums1.length; i++) {
            nums1[i] = nextGreater.getOrDefault(nums1[i], -1);
        }
        return nums1;

497. Random Point in Non-overlapping Rectangles
Medium

128

145

Favorite

Share
Given a list of non-overlapping axis-aligned rectangles rects, write a function pick which randomly and uniformily picks an integer point in the space covered by the rectangles.

Note:

An integer point is a point that has integer coordinates. 
A point on the perimeter of a rectangle is included in the space covered by the rectangles. 
ith rectangle = rects[i] = [x1,y1,x2,y2], where [x1, y1] are the integer coordinates of the bottom-left corner, and [x2, y2] are the integer coordinates of the top-right corner.
length and width of each rectangle does not exceed 2000.
1 <= rects.length <= 100
pick return a point as an array of integer coordinates [p_x, p_y]
pick is called at most 10000 times.
Example 1:

Input: 
["Solution","pick","pick","pick"]
[[[[1,1,5,5]]],[],[],[]]
Output: 
[null,[4,1],[4,1],[3,3]]
Example 2:

Input: 
["Solution","pick","pick","pick","pick","pick"]
[[[[-2,-2,-1,-1],[1,0,3,0]]],[],[],[],[],[]]
Output: 
[null,[-1,-2],[2,0],[-2,-1],[3,0],[-2,-2]]
Explanation of Input Syntax:

The input is two lists: the subroutines called and their arguments. Solution's constructor has one argument, the array of rectangles rects. pick has no arguments. Arguments are always wrapped with a list, even if there aren't any.

class Solution {
    TreeMap<Integer, Integer> map;
    int[][] arrays;
    int sum;
    Random rnd= new Random();
    
    public Solution(int[][] rects) {
        arrays = rects;
        map = new TreeMap<>();
        sum = 0;
        
        for(int i = 0; i < rects.length; i++) {
            int[] rect = rects[i];
                        
            // the right part means the number of points can be picked in this rectangle
            sum += (rect[2] - rect[0] + 1) * (rect[3] - rect[1] + 1);
            
            map.put(sum, i);
        }
    }
    
    public int[] pick() {
        // nextInt(sum) returns a num in [0, sum -1]. After added by 1, it becomes [1, sum]
        int c = map.ceilingKey( rnd.nextInt(sum) + 1);
        
        return pickInRect(arrays[map.get(c)]);
    }
    
    private int[] pickInRect(int[] rect) {
        int left = rect[0], right = rect[2], bot = rect[1], top = rect[3];
        
        return new int[]{left + rnd.nextInt(right - left + 1), bot + rnd.nextInt(top - bot + 1) };
    }
}
class Solution {

    rects = null;
    Map<Integer,Integer> map = new TreeMap<>();
    int s = 0;
    public Solution(int[][] rects) {
        this.rects=rects;
        for(int i = 0 ;i<rects.length;i++){
            int[] r=rects[i];
            s+=(r[2]-r[0]+1)*(r[3]-r[1]+1);
             map.put(s,i);
        }
    }
    
    Random rr = new Random();
    public int[] pick() {
        int k = map.ceilingKey(rr.nextInt(s+1));
        int[] r = map.get(k);
        return new int[]{r[0]+rr.nextInt(r[2]-r[0]+1),r[1]+rr.nextInt(r[3]-r[1]+1)};
    }
}

/**
 * Your Solution object will be instantiated and called as such:
 * Solution obj = new Solution(rects);
 * int[] param_1 = obj.pick();
 */

 498. Diagonal Traverse
Medium

428

256

Favorite

Share
Given a matrix of M x N elements (M rows, N columns), return all elements of the matrix in diagonal order as shown in the below image.

 

Example:

Input:
[
 [ 1, 2, 3 ],
 [ 4, 5, 6 ],
 [ 7, 8, 9 ]
]

Output:  [1,2,4,7,5,3,6,8,9]

Explanation:

 

Note:

The total number of elements of the given matrix will not exceed 10,000.

class Solution {
    public int[] findDiagonalOrder(int[][] m) {
       if(m.length==0)return new int[0];
        int x = 0,y=0;
        boolean a = false;
        int i =0;
        int[] ii = new int[m.length*m[0].length];
        while(i<ii.length){
            ii[i]=m[x][y];
            i++;
            if(!a){
                if(y+1==m[0].length){
                    x=x+1;
                    a=true;
                }
                else if(x-1<0){
                    y=y+1;
                    a=true;
                }else{
                    x=x-1;
                    y=y+1;
                }
                
            }else{
                if(x+1==m.length){
                    y=y+1;
                    a=false;
                }else if(y-1<0){
                    x=x+1;
                    a=false;
                }else{
                    x=x+1;
                    y=y-1;
                }
            }

        }
        return ii;
    }
}

500. Keyboard Row
Easy

433

547

Favorite

Share
Given a List of words, return the words that can be typed using letters of alphabet on only one row's of American keyboard like the image below.

 



 
Example:

Input: ["Hello", "Alaska", "Dad", "Peace"]
Output: ["Alaska", "Dad"]
 

Note:

You may use one character in the keyboard more than once.
You may assume the input string will only contain letters of alphabet.

class Solution {
    String q = "qwertyuiopQWERTYUIOP", w="asdfghjklASDFGHJKL",e="zxcvbnmZXCVBNM";
    public String[] findWords(String[] words) {
        List<String> list = new ArrayList<>();
        for(String s : words){
            String z = null;
            boolean b = true;
            for(char c : s.toCharArray()){
                if(z==null){
                    if(q.indexOf(c)>-1){
                        z=q;
                    }else if(w.indexOf(c)>-1){
                        z=w;
                    }else if(e.indexOf(c)>-1){
                        z=e;
                    }else{
                        b=false;
                    }
                }else{
                    if(z.indexOf(c)==-1){
                        b=false;
                    }
                }
            }
            if(b){
                list.add(s);
            }
        }  

        return list.toArray(new String[list.size()]);  
        
    }
}



501. Find Mode in Binary Search Tree
Easy

641

261

Favorite

Share
Given a binary search tree (BST) with duplicates, find all the mode(s) (the most frequently occurred element) in the given BST.

Assume a BST is defined as follows:

The left subtree of a node contains only nodes with keys less than or equal to the node's key.
The right subtree of a node contains only nodes with keys greater than or equal to the node's key.
Both the left and right subtrees must also be binary search trees.
 

For example:
Given BST [1,null,2,2],

   1
    \
     2
    /
   2
 

return [2].

Note: If a tree has more than one mode, you can return them in any order.

Follow up: Could you do that without using any extra space? (Assume that the implicit stack space incurred due to recursion does not count).

vector<int> findMode(TreeNode* root) {
        vector<int> res;
        int mx = 0, cnt = 1;
        TreeNode *pre = NULL;
        inorder(root, pre, cnt, mx, res);
        return res;
    }
    void inorder(TreeNode* node, TreeNode*& pre, int& cnt, int& mx, vector<int>& res) {
        if (!node) return;
        inorder(node->left, pre, cnt, mx, res);
        if (pre) {
            cnt = (node->val == pre->val) ? cnt + 1 : 1;
        }
        if (cnt >= mx) {
            if (cnt > mx) res.clear();
            res.push_back(node->val);
            mx = cnt;
        } 
        pre = node;
        inorder(node->right, pre, cnt, mx, res);
    }
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
Set<Integer> list = new HashSet<>();
    int c =1;
    int m = 0;
    TreeNode p = null;
  public int[] findMode(TreeNode root) {
    q(root);
    int[] ii = new int[list.size()];
      int i = 0;
      for(int q : list){
          ii[i]=q;
          i++;
      }
    

    return ii;

  }

  public void q(TreeNode n){
    if(n==null)return ;
    q(n.left);
    if(p!=null){
        c = (p.val==n.val)?c+1:1;
    }

    if(c>=m){
        if(c>m)list.clear();
        list.add(n.val);
        m=c;
    }
    p=n;
    q(n.right);

  }

[6,2,8,0,4,7,9,null,null,2,6]
    public int q(TreeNode root,int i,Map<Integer,Integer> map){
        if(root==null){
            return 0;
        }
        if(root.val!=i){
            int q = q(root.left,root.val,map);
            int w = q(root.right,root.val,map);
            map.put(root.val,1+q+w);
            return 0;
        }

        int z = q(root.left,i,map)+1;
        int x = q(root.right,i,map)+1;

        return z+x;


    }
}


502. IPO
Hard

229

23

Favorite

Share
Suppose LeetCode will start its IPO soon. In order to sell a good price of its shares to Venture Capital, LeetCode would like to work on some projects to increase its capital before the IPO. Since it has limited resources, it can only finish at most k distinct projects before the IPO. Help LeetCode design the best way to maximize its total capital after finishing at most k distinct projects.

You are given several projects. For each project i, it has a pure profit Pi and a minimum capital of Ci is needed to start the corresponding project. Initially, you have W capital. When you finish a project, you will obtain its pure profit and the profit will be added to your total capital.

To sum up, pick a list of at most k distinct projects from given projects to maximize your final capital, and output your final maximized capital.

Example 1:
Input: k=2, W=0, Profits=[1,2,3], Capital=[0,1,1].

Output: 4

Explanation: Since your initial capital is 0, you can only start the project indexed 0.
             After finishing it you will obtain profit 1 and your capital becomes 1.
             With capital 1, you can either start the project indexed 1 or the project indexed 2.
             Since you can choose at most 2 projects, you need to finish the project indexed 2 to get the maximum capital.
             Therefore, output the final maximized capital, which is 0 + 1 + 3 = 4.
Note:
You may assume all numbers in the input are non-negative integers.
The length of Profits array and Capital array will not exceed 50,000.
The answer is guaranteed to fit in a 32-bit signed integer.


10
0
[1,2,3]
[0,1,2]
6
class Solution {
    public int findMaximizedCapital(int k, int w, int[] p, int[] c) {

        PriorityQueue<int[]> pp = new PriorityQueue<>((a,b)->(a[0]-b[0]));
        PriorityQueue<int[]> qq = new PriorityQueue<>((a,b)->(b[1]-a[1]));
        for(int i = 0;i<p.length;i++){
            pp.add(new int[]{c[i],p[i]});
        }
        

        for(int i =0;i<k;i++){
            while(!pp.isEmpty()&&pp.peek()[0]<w){
                qq.add(pp.poll());
            }

            if(qq.isEmpty()){
                break;
            }
            w+=qq.poll()[1];
        }
        return w;

        Map<Integer,Integer> map = new HashMap<>();
        for(int i = 0;i<Profits.length;i++){
            int z = map.getOrDefault(Capital[i],0);
            map.put(Capital[i],Profits[i]>z?Profits[i]:z);
        }

        return q(k,W,map);
    }

    public int q(int k,int w,Map<Integer,Integer> map){
        if(k==0)return 0;
        int max = 0;
        for(Map.Entry<Integer,Integer> entry:map.entrySet()){
            if(w>=entry.getKey()){
                int x = entry.getValue()+q(k-1,w+entry.getValue(),map);
                max=Math.max(max,x-w);
            }
        }
        return max+w;

    }
}

The idea is each time we find a project with max profit and within current capital capability.
Algorithm:

Create (capital, profit) pairs and put them into PriorityQueue pqCap. This PriorityQueue sort by capital increasingly.
Keep polling pairs from pqCap until the project out of current capital capability. Put them into
PriorityQueue pqPro which sort by profit decreasingly.
Poll one from pqPro, it's guaranteed to be the project with max profit and within current capital capability. Add the profit to capital W.
Repeat step 2 and 3 till finish k steps or no suitable project (pqPro.isEmpty()).
Time Complexity: For worst case, each project will be inserted and polled from both PriorityQueues once, so the overall runtime complexity should be O(NlgN), N is number of projects.

public class Solution {
    public int findMaximizedCapital(int k, int W, int[] Profits, int[] Capital) {
        PriorityQueue<int[]> pqCap = new PriorityQueue<>((a, b) -> (a[0] - b[0]));
        PriorityQueue<int[]> pqPro = new PriorityQueue<>((a, b) -> (b[1] - a[1]));
        
        for (int i = 0; i < Profits.length; i++) {
            pqCap.add(new int[] {Capital[i], Profits[i]});
        }
        
        for (int i = 0; i < k; i++) {
            while (!pqCap.isEmpty() && pqCap.peek()[0] <= W) {
                pqPro.add(pqCap.poll());
            }
            
            if (pqPro.isEmpty()) break;
            
            W += pqPro.poll()[1];
        }
        
        return W;
    }

503. Next Greater Element II
Medium

856

49

Favorite

Share
Given a circular array (the next element of the last element is the first element of the array), print the Next Greater Number for every element. The Next Greater Number of a number x is the first greater number to its traversing-order next in the array, which means you could search circularly to find its next greater number. If it doesn't exist, output -1 for this number.

Example 1:
Input: [1,2,1]
Output: [2,-1,2]
Explanation: The first 1's next greater number is 2; 
The number 2 can't find next greater number; 
The second 1's next greater number needs to search circularly, which is also 2.
Note: The length of given array won't exceed 10000.

class Solution {
    public int[] nextGreaterElements(int[] nums) {
        int[] ii = new int[nums.length];
        for(int i = 0;i<nums.length;i++){
            ii[i]=-1;
            int j = i+1;
             while(j!=i){
                if(j==nums.length){
                    if(i==0)break;
                    j=0;
                }

                if(nums[j]>nums[i]){
                    ii[i]=nums[j];

                    break;
                }
                j++;


            }
        }
        return ii;
    }
}

The approach is same as Next Greater Element I
See explanation in my solution to the previous problem
The only difference here is that we use stack to keep the indexes of the decreasing subsequence

Java

    public int[] nextGreaterElements(int[] nums) {
        int n = nums.length, next[] = new int[n];
        Arrays.fill(next, -1);
        Stack<Integer> stack = new Stack<>(); // index stack
        for (int i = 0; i < n * 2; i++) {
            int num = nums[i % n]; 
            while (!stack.isEmpty() && nums[stack.peek()] < num)
                next[stack.pop()] = num;
            if (i < n) stack.push(i);
        }   
        return next;
    }
C++

504. Base 7
Easy

170

129

Favorite

Share
Given an integer, return its base 7 string representation.

Example 1:
Input: 100
Output: "202"
Example 2:
Input: -7
Output: "-10"
Note: The input will be in range of [-1e7, 1e7].

class Solution {
    public String convertToBase7(int num) {
        if(num<0)return "-"+convertToBase7(num);
        if(num<7)return num+"";

        return convertToBase7(num/7)+num%7;
        String s = "";
        if(num<0){
            num=0-num;
            s="-";
        }
        while(num>0){
            int z = num%7;
            s=z+s;
            num=num/7;
        }
        return s;
    }
}


506. Relative Ranks
Easy

205

425

Favorite

Share
Given scores of N athletes, find their relative ranks and the people with the top three highest scores, who will be awarded medals: "Gold Medal", "Silver Medal" and "Bronze Medal".

Example 1:
Input: [5, 4, 3, 2, 1]
Output: ["Gold Medal", "Silver Medal", "Bronze Medal", "4", "5"]
Explanation: The first three athletes got the top three highest scores, so they got "Gold Medal", "Silver Medal" and "Bronze Medal". 
For the left two athletes, you just need to output their relative ranks according to their scores.
Note:
N is a positive integer and won't exceed 10,000.
All the scores of athletes are guaranteed to be unique.

class Solution {
    public String[] findRelativeRanks(int[] nums) {
        String[] ss = new String[nums.length];

        
        int j= 0;
        while(j<nums.length){
            int m = -1;
            int k = 0;
            for(int i = 0;i<nums.length;i++){
                if(nums[i]>m){
                    k=i;
                    m=nums[i];
                }
            }
            nums[k]=-1;
            if(j==0){
                ss[k]="Gold Medal";
            }else if(j==1){
                ss[k]="Silver Medal";
            }else if(j==2){
                ss[k]="Bronze Medal";
            }else{
                ss[k]==(j+1)+"";
            }
            j++;
        }
        return ss;
        
        
    }
}

507. Perfect Number
Easy

183

504

Favorite

Share
We define the Perfect Number is a positive integer that is equal to the sum of all its positive divisors except itself.

Now, given an integer n, write a function that returns true when it is a perfect number and false when it is not.
Example:
Input: 28
Output: True
Explanation: 28 = 1 + 2 + 4 + 7 + 14
Note: The input number n will not exceed 100,000,000. (1e8)

class Solution {
    public boolean checkPerfectNumber(int num) {
        if(num==1)return false;
        int q = (int)Math.sqrt(num)+1;
        int s = 1;
        for(int i = 2;i<q;i++){
            if(num%i==0){
                s=s+i;
                if(i!=num/i){
                    s+=num/i;
                }
            }
        }
        return s==num;
    }
}

508. Most Frequent Subtree Sum
Medium

452

91

Favorite

Share
Given the root of a tree, you are asked to find the most frequent subtree sum. The subtree sum of a node is defined as the sum of all the node values formed by the subtree rooted at that node (including the node itself). So what is the most frequent subtree sum value? If there is a tie, return all the values with the highest frequency in any order.

Examples 1
Input:

  5
 /  \
2   -3
return [2, -3, 4], since all the values happen only once, return all of them in any order.
Examples 2
Input:

  5
 /  \
2   -5
return [2], since 2 happens twice, however -5 only occur once.
Note: You may assume the sum of values in any subtree is in the range of 32-bit signed integer.

/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    int max=0;
    public int[] findFrequentTreeSum(TreeNode root) {
         Map<Integer,Integer> map = new HashMap<>();
        q(root,map);
        List<Integer> list = new ArrayList<>();
        for(Map.Entry<Integer,Integer> entry:map.entrySet()){
            if(entry.getValue()==max){
                list.add(entry.getKey());
            }
        }
        int[] ii = new int[list.size()];
        for(int i = 0;i<ii.length;i++){
            ii[i]=list.get(i);
        }
        return ii;        
        
    }

    public int q(TreeNode node,Map<Integer,Integer> map ){
        if(node==null){
            return 0;
        }

        int s = node.val;
        s+=q(node.left,map);
        s+=q(node.right,map);
        int j = map.getOrDefault(s,0)+1;
        map.put(s,j);
        max=Math.max(max,j);
        return s;
    }
}

509. Fibonacci Number
Easy

308

164

Favorite

Share
The Fibonacci numbers, commonly denoted F(n) form a sequence, called the Fibonacci sequence, such that each number is the sum of the two preceding ones, starting from 0 and 1. That is,

F(0) = 0,   F(1) = 1
F(N) = F(N - 1) + F(N - 2), for N > 1.
Given N, calculate F(N).

class Solution {
    public int fib(int n) {
        if(n<=1)return n;
        int q = 0,w=1;
        for(int i=2;i<=n;i++){
            int t = q;
            q =w;
            w=t+q;
        }
        return w;
    }
}

513. Find Bottom Left Tree Value
Medium

656

112

Favorite

Share
Given a binary tree, find the leftmost value in the last row of the tree.

Example 1:
Input:

    2
   / \
  1   3

Output:
1
Example 2: 
Input:

        1
       / \
      2   3
     /   / \
    4   5   6
       /
      7

Output:
7
Note: You may assume the tree (i.e., the given root node) is not NULL.
[1,2,3,4,null,5,6,null,null,7]
class Solution {
    int z = 0;
    int q = 0;
    public int findBottomLeftValue(TreeNode root) {

        q=root.val;
        q(root,0);
        return q;
    }

    public void q(TreeNode node,int t){
        if(node ==null)return ;
        t++;
        if(t>z){
            if(node.left!=null){
                z=t;
                q=node.left.val;
            }else if(node.right!=null){
                z=t;
                q=node.right.val;
            }
            
        }
        q(node.left,t);
        q(node.right,t);

    }
}

514. Freedom Trail
Hard

318

18

Favorite

Share
In the video game Fallout 4, the quest "Road to Freedom" requires players to reach a metal dial called the "Freedom Trail Ring", and use the dial to spell a specific keyword in order to open the door.

Given a string ring, which represents the code engraved on the outer ring and another string key, which represents the keyword needs to be spelled. You need to find the minimum number of steps in order to spell all the characters in the keyword.

Initially, the first character of the ring is aligned at 12:00 direction. You need to spell all the characters in the string key one by one by rotating the ring clockwise or anticlockwise to make each character of the string key aligned at 12:00 direction and then by pressing the center button.

At the stage of rotating the ring to spell the key character key[i]:

You can rotate the ring clockwise or anticlockwise one place, which counts as 1 step. The final purpose of the rotation is to align one of the string ring's characters at the 12:00 direction, where this character must equal to the character key[i].
If the character key[i] has been aligned at the 12:00 direction, you need to press the center button to spell, which also counts as 1 step. After the pressing, you could begin to spell the next character in the key (next stage), otherwise, you've finished all the spelling.
Example:


 
Input: ring = "godding", key = "gd"
Output: 4
Explanation:
For the first key character 'g', since it is already in place, we just need 1 step to spell this character. 
For the second key character 'd', we need to rotate the ring "godding" anticlockwise by two steps to make it become "ddinggo".
Also, we need 1 more step for spelling.
So the final output is 4.
Note:

Length of both ring and key will be in range 1 to 100.
There are only lowercase letters in both strings and might be some duplcate characters in both strings.
It's guaranteed that string key could always be spelled by rotating the string ring.
主虽然没有玩过这款游戏，但是知道确实有些游戏中需要破解一些谜题才能继续通关，像博主很早以前玩过的恐龙危机啊，生化危机啊啥的，都有一些机关需要破解，博主大部分都要靠看攻略来通关哈哈。这道题讲的是一种叫做自由之路的机关，我们需要将密码字符串都转出来，让我们求最短的转动步数。博主最先尝试的用贪婪算法来做，就是每一步都选最短的转法，但是OJ中总有些test case会引诱贪婪算法得出错误的结果，因为全局最优解不一定都是局部最优解，而贪婪算法一直都是在累加局部最优解，这也是为啥DP解法这么叼的原因。贪婪算法好想好实现，但是不一定能得到正确的结果。DP解法难想不好写，但往往才是正确的解法，这也算一个trade off吧。这道题可以用DP来解，难点还是写递推公式，博主在充分研究网上大神们的帖子后尝试着自己理理思路，如果有不正确或者不足的地方，也请各位不吝赐教。此题需要使用一个二维数组dp，其中dp[i][j]表示转动从i位置开始的key串所需要的最少步数(这里不包括spell的步数，因为spell可以在最后统一加上)，此时表盘的12点位置是ring中的第j个字符。不得不佩服这样的设计的确很巧妙，我们可以从key的末尾往前推，这样dp[0][0]就是我们所需要的结果，因为此时是从key的开头开始转动，而且表盘此时的12点位置也是ring的第一个字符。现在我们来看如何找出递推公式，对于dp[i][j]，我们知道此时要将key[i]转动到12点的位置，而此时表盘的12点位置是ring[j]，我们有两种旋转的方式，顺时针和逆时针，我们的目标肯定是要求最小的转动步数，而顺时针和逆时针的转动次数之和刚好为ring的长度n，这样我们求出来一个方向的次数，就可以迅速得到反方向的转动次数。为了将此时表盘上12点位置上的ring[j]转动到key[i]，我们要将表盘转动一整圈，当转到key[i]的位置时，我们计算出转动步数diff，然后计算出反向转动步数，并取二者较小值为整个转动步数step，此时我们更新dp[i][j]，更新对比值为step + dp[i+1][k]，这个也不难理解，因为key的前一个字符key[i+1]的转动情况suppose已经计算好了，那么dp[i+1][k]就是当时表盘12点位置上ring[k]的情况的最短步数，step就是从ring[k]转到ring[j]的步数，也就是key[i]转到ring[j]的步数，用语言来描述就是，从key的i位置开始转动并且此时表盘12点位置为ring[j]的最小步数(dp[i][j])就等价于将ring[k]转动到12点位置的步数(step)加上从key的i+1位置开始转动并且ring[k]已经在表盘12点位置上的最小步数(dp[i+1][k])之和。突然发现这不就是之前那道Reverse Pairs中解法一中归纳的顺序重现关系的思路吗，都做了总结，可换个马甲就又不认识了，泪目中。。。
The dp is a 2D integer array, with height = the length of ring, with width = the length of key. So DP[i][j] represents that if we want to spell the next character key[j], and at the same time the 12:00 aligns with the ring[i], then what is the minimum steps to spell the whole key start at key[j]. If we finish the DP array, then the answer is just DP[0][0], which means the minimum steps to spell the whole key start at key[0], if currently 12:00 aligns with the ring[0], and this is exactly the original problem. And don't forget to plus the length of key, which is the steps we need to push the button.

// by fallcreek
public class Solution {
    public int findRotateSteps(String ring, String key) {        
        int[][] dp = new int[ring.length()][key.length()];
        for(int[] line : dp)    Arrays.fill(line, -1);
        
        return helper(ring, 0, key, 0, dp) + key.length();
    }
    
    public int helper(String ring, int rIndex, String key, int kIndex, int[][] dp){
        if(kIndex == key.length()) return 0;
        if(dp[rIndex][kIndex] != -1) return dp[rIndex][kIndex];
        
        char dest = key.charAt(kIndex);
        
        int nextIndex = ring.indexOf(dest);
        int sol = Integer.MAX_VALUE;
        do{
            int move = Math.min(Math.abs(rIndex - nextIndex), ring.length() - Math.abs(rIndex - nextIndex));
            int remain = helper(ring, nextIndex, key, kIndex + 1, dp);
            sol = Math.min(sol, move + remain);
            nextIndex = ring.indexOf(dest, nextIndex + 1);
        }while(nextIndex != -1);
        dp[rIndex][kIndex] = sol;
        return sol;
    }
}
class Solution {
    public int findRotateSteps(String ring, String key) {
         int[][] ii = new int[ring.length()][key.length()];
         for(int[] i : ii)Arrays.fill(i,-1);
         return q(ring,key,0,0,ii)+key.length();
    }

    public int q(String r,String k,int i,int j,int[][] ii){
        if(j==k.length())return 0;
        if(ii[i][j]!=-1)return ii[i][j];
        int q = Integer.MAX_VALUE;
        char c = k.charAt(j);
        int a = 0;
        int z = -1;
        while((z = r.indexOf(c,a))!=-1){
            int m = Math.min(Math.abs(z-i),r.length()-Math.abs(z-i));
            q=Math.min(q,m+q(r,k,z,j+1,ii));
            a=z+1;
        }
        ii[i][j]=q;
        return q;
    }
}

515. Find Largest Value in Each Tree Row
Medium

585

48

Favorite

Share
You need to find the largest value in each row of a binary tree.

Example:
Input: 

          1
         / \
        3   2
       / \   \  
      5   3   9 

Output: [1, 3, 9]

class Solution {

    public List<Integer> largestValues(TreeNode root) {
        
        List<Integer> list = new ArrayList<>();
        q(root,0,list);
        return list;
    }

    public void q(TreeNode node,int i,List<Integer> list){
        if(node==null)return;
        if(list.size()<i+1){
            list.add(node.val);
        }else{
            list.set(i,Math.max(list.get(i),node.val));
        }
        if(q==null)q=Integer.MIN_VALUE;
        list.add(i,Math.max(q,node.val));
        q(node.left,i+1,list);
        q(node.right,i+1,list);
    }
}

516. Longest Palindromic Subsequence
Medium

1191

148

Favorite

Share
Given a string s, find the longest palindromic subsequence's length in s. You may assume that the maximum length of s is 1000.

Example 1:
Input:

"bbbab"
Output:
4
One possible longest palindromic subsequence is "bbbb".
Example 2:
Input:

"cbbd"
Output:
2
One possible longest palindromic subsequence is "bb".
class Solution {
    public int longestPalindromeSubseq(String s) {

        int[][] ii = new int[s.length()][s.length()];
        for(int i = 0 ;i<s.length();i++){
            ii[i][i]=1;
            for(int j=i-1;j>-1;j--){
                if(s.charAt(i)==s.charAt(j)){
                    ii[j][i]=ii[j+1][i-1]+2;
                }else{
                    ii[j][i]=Math.max(ii[j+1][i],ii[j][i-1]);
                }
            }

        }
        return ii[0][s.length()-1];

        
    }

}

517,Super Washing Machines
Hard

233

122

Favorite

Share
You have n super washing machines on a line. Initially, each washing machine has some dresses or is empty.

For each move, you could choose any m (1 ≤ m ≤ n) washing machines, and pass one dress of each washing machine to one of its adjacent washing machines at the same time .

Given an integer array representing the number of dresses in each washing machine from left to right on the line, you should find the minimum number of moves to make all the washing machines have the same number of dresses. If it is not possible to do it, return -1.

Example1

Input: [1,0,5]

Output: 3

Explanation: 
1st move:    1     0 <-- 5    =>    1     1     4
2nd move:    1 <-- 1 <-- 4    =>    2     1     3    
3rd move:    2     1 <-- 3    =>    2     2     2   
Example2

Input: [0,3,0]

Output: 2

Explanation: 
1st move:    0 <-- 3     0    =>    1     2     0    
2nd move:    1     2 --> 0    =>    1     1     1     
Example3

Input: [0,2,0]

Output: -1

Explanation: 
It's impossible to make all the three washing machines have the same number of dresses. 
Note:
The range of n is [1, 10000].
The range of dresses number in a super washing machine is [0, 1e5].
class Solution {
    public int findMinMoves(int[] machines) {
        int sum = 0;
        for(int i : machines){
            sum+=i;
        }
        if(sum%machines.length!=0){
            return -1;
        }

        int a = sum/machines.length;

        int max = 0;
        int q = 0;
        for(int i : machines){
            q=i-a+q;
            max=Math.max(i-a,Math.max(Math.abs(q),max));
        }
        return max;
        

        
    }
}


518. Coin Change 2
Medium

1016

43

Favorite

Share
You are given coins of different denominations and a total amount of money. Write a function to compute the number of combinations that make up that amount. You may assume that you have infinite number of each kind of coin.

 

Example 1:

Input: amount = 5, coins = [1, 2, 5]
Output: 4
Explanation: there are four ways to make up the amount:
5=5
5=2+2+1
5=2+1+1+1
5=1+1+1+1+1
Example 2:

Input: amount = 3, coins = [2]
Output: 0
Explanation: the amount of 3 cannot be made up just with coins of 2.
Example 3:

Input: amount = 10, coins = [10] 
Output: 1
 

Note:

You can assume that

0 <= amount <= 5000
1 <= coin <= 5000
the number of coins is less than 500
the answer is guaranteed to fit into signed 32-bit integer
class Solution {
    public int change(int amount, int[] coins) {
       int[] ii =new int[amount+1];
       ii[0]=1;
       for(int c :coins){
        for(int i = c;i<ii.length;i++){
            ii[i]+=ii[i-c];
        }
       }

       return ii[amount];
         

    }

    public int q(int a,int[] cs,int[] ii,int j){
        if(ii[a-1]>-1)return ii[a-1];
        int z = 0;
        for(int q = j;q>-1;q--){
            int i = cs[q];
            if(i>a){
                break;
            }else if(i==a){
                z++;
            }else{ 
                if(ii[a-i-1]>0){
                    z+= ii[a-i-1];
                }
            }

        }
        ii[a-1]=z;
        return z;
    }

    Arrays.sort(coins);
         int[] ii = new int[amount];
        return q(amount,coins,ii,0);
         

    }

      if(amount==0)return 1;
        Arrays.sort(coins);
        int i= q(amount,coins,0);
        return i;
    }

    public static int  q(int a,int[] cs,int j){
        int z = 0;
        for(int q = j;q<cs.length;q++){
            int i = cs[q];
            if(i>a){
                break;
            }else if(i==a){
                z++;
            }else{
                z+=q(a-i,cs,q);
            }

        }
        return z;
}

519. Random Flip Matrix
Medium

120

44

Favorite

Share
You are given the number of rows n_rows and number of columns n_cols of a 2D binary matrix where all values are initially 0. Write a function flip which chooses a 0 value uniformly at random, changes it to 1, and then returns the position [row.id, col.id] of that value. Also, write a function reset which sets all values back to 0. Try to minimize the number of calls to system's Math.random() and optimize the time and space complexity.

Note:

1 <= n_rows, n_cols <= 10000
0 <= row.id < n_rows and 0 <= col.id < n_cols
flip will not be called when the matrix has no 0 values left.
the total number of calls to flip and reset will not exceed 1000.
Example 1:

Input: 
["Solution","flip","flip","flip","flip"]
[[2,3],[],[],[],[]]
Output: [null,[0,1],[1,2],[1,0],[1,1]]
Example 2:

Input: 
["Solution","flip","flip","reset","flip"]
[[1,2],[],[],[],[]]
Output: [null,[0,0],[0,1],null,[0,0]]
Explanation of Input Syntax:

The input is two lists: the subroutines called and their arguments. Solution's constructor has two arguments, n_rows and n_cols. flip and reset have no arguments. Arguments are always wrapped with a list, even if there aren't any.



class Solution {

   int q,w;
   Random r = new Random();
   List<Integer> list = new ArrayList<>();
    public Solution(int z, int x) {
    q=z;
    w=x;
        
    }
    
    public int[] flip() {
        int i = r.nextInt(q*w-list.size());
        while(list.contains(i)){
            i++;
        }
        if(i>q*w){
            i=0;
            while(list.contains(i)){
                i++;
            }
        }
        
        list.add(i);
        return new int[]{i/w,i%w};
    }
    
    public void reset() {
        list.clear();
    }
}

/**
 * Your Solution object will be instantiated and called as such:
 * Solution obj = new Solution(n_rows, n_cols);
 * int[] param_1 = obj.flip();
 * obj.reset();
 */

 520. Detect Capital
Easy

348

224

Favorite

Share
Given a word, you need to judge whether the usage of capitals in it is right or not.

We define the usage of capitals in a word to be right when one of the following cases holds:

All letters in this word are capitals, like "USA".
All letters in this word are not capitals, like "leetcode".
Only the first letter in this word is capital, like "Google".
Otherwise, we define that this word doesn't use capitals in a right way.
 

Example 1:

Input: "USA"
Output: True
 

Example 2:

Input: "FlaG"
Output: False
 

Note: The input will be a non-empty word consisting of uppercase and lowercase latin letters.

class Solution {
    public boolean detectCapitalUse(String word) {
        if(word.length==1)return true;
        int i = 0;
        char c = word.charAt(i);
        boolean b = c>='a'&&c<='z';
        i++;
        if(!b){
            c=word.charAt(i);
             b = c>='a'&&c<='z';
             i++;
        }

        while(i<word.length()){

            c=word.charAt(i);
            if(b != c>='a'&&c<='z'){
                return false;
            }
            i++;
        }
        
        return true;
    }
}

521. Longest Uncommon Subsequence I
Easy

230

3689

Favorite

Share
Given a group of two strings, you need to find the longest uncommon subsequence of this group of two strings. The longest uncommon subsequence is defined as the longest subsequence of one of these strings and this subsequence should not be any subsequence of the other strings.

A subsequence is a sequence that can be derived from one sequence by deleting some characters without changing the order of the remaining elements. Trivially, any string is a subsequence of itself and an empty string is a subsequence of any string.

The input will be two strings, and the output needs to be the length of the longest uncommon subsequence. If the longest uncommon subsequence doesn't exist, return -1.

Example 1:
Input: "aba", "cdc"
Output: 3
Explanation: The longest uncommon subsequence is "aba" (or "cdc"), 
because "aba" is a subsequence of "aba", 
but not a subsequence of any other strings in the group of two strings. 
Note:

Both strings' lengths will not exceed 100.
Only letters from a ~ z will appear in input strings.
class Solution {
    public int findLUSlength(String a, String b) {
        return a.equals(b)?-1:a.length()>b.length?a.length():b.length();
        
    }
}

522. Longest Uncommon Subsequence II
Medium

126

518

Favorite

Share
Given a list of strings, you need to find the longest uncommon subsequence among them. The longest uncommon subsequence is defined as the longest subsequence of one of these strings and this subsequence should not be any subsequence of the other strings.

A subsequence is a sequence that can be derived from one sequence by deleting some characters without changing the order of the remaining elements. Trivially, any string is a subsequence of itself and an empty string is a subsequence of any string.

The input will be a list of strings, and the output needs to be the length of the longest uncommon subsequence. If the longest uncommon subsequence doesn't exist, return -1.

Example 1:
Input: "aba", "cdc", "eae"
Output: 3
Note:

All the given strings' lengths will not exceed 10.
The length of the given list will be in the range of [2, 50].

class Solution {
    public int findLUSlength(String[] strs) {
        Arrays.sort(strs,(x,y)->y.length()==x.length()?x.compareTo(y):y.length()-x.length());
        int i = 0;
        while(i+1<strs.length){
            if(!strs[i].equals(strs[i+1])){
                return strs[i].length();
            }
            i++;
        }

       return -1;

    }
}

523. Continuous Subarray Sum
Medium

873

1198

Favorite

Share
Given a list of non-negative numbers and a target integer k, write a function to check if the array has a continuous subarray of size at least 2 that sums up to a multiple of k, that is, sums up to n*k where n is also an integer.

 

Example 1:

Input: [23, 2, 4, 6, 7],  k=6
Output: True
Explanation: Because [2, 4] is a continuous subarray of size 2 and sums up to 6.
Example 2:

Input: [23, 2, 6, 4, 7],  k=6
Output: True
Explanation: Because [23, 2, 6, 4, 7] is an continuous subarray of size 5 and sums up to 42.
 

Note:

The length of the array won't exceed 10,000.
You may assume the sum of all the numbers is in the range of a signed 32-bit integer.

class Solution {
    public boolean checkSubarraySum(int[] nums, int k) {
        Set<Integer> ss = new HashSet<>();int sum = 0,t=0;
        for(int s : nums ){
            sum+=s;
            int z=(k==0)?sum:(sum%k);
            if(ss.contains(z))return true;
            ss.add(t);
            t=z;
        }
        return false;
        for(int i = 0 ;i<nums.length;i++){
            int sum = nums[i];
            for(int j = i+1;i<nums.length;j++){
                sum+=nums[j];
                if(sum==k)return true;
                if(k!=0&&sum%k==0)return true;

            }
        }
        return false;
       
        
    }

    public boolean q(int[] nums,int k ,int sum,int i,int z){
        if((k==sum||(k!=0&&sum%k==0)&&z>1)return true;
        if(i==nums.length-1)return false;
        return q(nums,k,sum+nums[i],i+1,z+1)||q(nums,k,sum,i+1,z);
    }

    ix + t = y
    jx + t = k
    (y-k)%x==0;

}
[23,2,6,4,7]
6

524. Longest Word in Dictionary through Deleting
Medium

403

196

Favorite

Share
Given a string and a string dictionary, find the longest string in the dictionary that can be formed by deleting some characters of the given string. If there are more than one possible results, return the longest word with the smallest lexicographical order. If there is no possible result, return the empty string.

Example 1:
Input:
s = "abpcplea", d = ["ale","apple","monkey","plea"]

Output: 
"apple"
Example 2:
Input:
s = "abpcplea", d = ["a","b","c"]

Output: 
"a"
Note:
All the strings in the input will only contain lower-case letters.
The size of the dictionary won't exceed 1,000.
The length of all the strings in the input won't exceed 1,000.

class Solution {
    public String findLongestWord(String s, List<String> d) {
         d.sort((x,y)->{
         if(y.length()==x.length()){
            return x.compareTo(y);
         }
         return y.length()-x.length();
         });
        for(String q : d){
            int i = 0;
            for(char c : q.toCharArray()){
                if(i<s.length()){
                    i=s.indexOf(c,i);
                    if(i<-1 )break;
                    i++;
                }else{
                    i=-1;
                    break;
                }
                
            }
            if(i!=-1)return q;
        }
        return "";
        
    }
}


525. Contiguous Array
Medium

891

45

Favorite

Share
Given a binary array, find the maximum length of a contiguous subarray with equal number of 0 and 1.

Example 1:
Input: [0,1]
Output: 2
Explanation: [0, 1] is the longest contiguous subarray with equal number of 0 and 1.
Example 2:
Input: [0,1,0]
Output: 2
Explanation: [0, 1] (or [1, 0]) is a longest contiguous subarray with equal number of 0 and 1.
Note: The length of the given binary array will not exceed 50,000.

class Solution {
    public int findMaxLength(int[] nums) {
        int k = 0;
        Map<Integer,Integer> map = new HashMap<>();
        int max =0;
        for(int i = 0 ;i<nums.length;i++){
            if(nums[i]==0){
                k--;
            }else{
                k++;
            }

            if(k==0){
                max=Math.max(max,i+1);
            }else{
                Integer q = map.get(k);
                if(q!=null){
                    max=Math.max(max,i-q);
                }else{
                    map.put(k,i);
                }

                
            }
            

        }
        return max;
        
        
    }
}

526. Beautiful Arrangement
Medium

519

130

Favorite

Share
Suppose you have N integers from 1 to N. We define a beautiful arrangement as an array that is constructed by these N numbers successfully if one of the following is true for the ith position (1 <= i <= N) in this array:

The number at the ith position is divisible by i.
i is divisible by the number at the ith position.
 

Now given N, how many beautiful arrangements can you construct?

Example 1:

Input: 2
Output: 2
Explanation: 

The first beautiful arrangement is [1, 2]:

Number at the 1st position (i=1) is 1, and 1 is divisible by i (i=1).

Number at the 2nd position (i=2) is 2, and 2 is divisible by i (i=2).

The second beautiful arrangement is [2, 1]:

Number at the 1st position (i=1) is 2, and 2 is divisible by i (i=1).

Number at the 2nd position (i=2) is 1, and i (i=2) is divisible by 1.
 

Note:

N is a positive integer and will not exceed 15.

class Solution {
    public int countArrangement(int N) {
        int[] ii = new int[N];
        return q(ii,1);
    }

    public int q(int[] ii,int i){
        if(i>ii.length)return 1;
        int z = 0;
        for(int j = 0 ;j<ii.length;j++){
            if(ii[j]==1){
                continue;
            }

            if((j+1)%i==0||i%(j+1)==0){
                ii[j]=1;
                z+=q(ii,i+1);
                ii[j]=0;
            }
        }
        return z;
    }
}



528. Random Pick with Weight
Medium

401

760

Favorite

Share
Given an array w of positive integers, where w[i] describes the weight of index i, write a function pickIndex which randomly picks an index in proportion to its weight.

Note:

1 <= w.length <= 10000
1 <= w[i] <= 10^5
pickIndex will be called at most 10000 times.
Example 1:

Input: 
["Solution","pickIndex"]
[[[1]],[]]
Output: [null,0]
Example 2:

Input: 
["Solution","pickIndex","pickIndex","pickIndex","pickIndex","pickIndex"]
[[[1,3]],[],[],[],[],[]]
Output: [null,0,1,1,1,0]
Explanation of Input Syntax:

The input is two lists: the subroutines called and their arguments. Solution's constructor has one argument, the array w. pickIndex has no arguments. Arguments are always wrapped with a list, even if there aren't any.
 
class Solution {

    int sum = 0;
    int[] q;
    public Solution(int[] w) {
        for(int i = 0 ;i<w.length;i++){
            sum+=w[i];
            w[i]=sum;
        }
        q=w;
        
    }
    
    public int pickIndex() {
        int i = (int)(Math.random()*sum);
        int j = 0;
        if(q[j]>i){
    
                return j;
            }
        for(j++;j<q.length;j+=2){
            if(q[j]>i){
                if(q[j-1]>i){
                    return j-1;
                }
                return j;
            }
        }
        return q.length-1;

    }
}

529. Minesweeper
Medium

430

396

Favorite

Share
Let's play the minesweeper game (Wikipedia, online game)!

You are given a 2D char matrix representing the game board. 'M' represents an unrevealed mine, 'E' represents an unrevealed empty square, 'B' represents a revealed blank square that has no adjacent (above, below, left, right, and all 4 diagonals) mines, digit ('1' to '8') represents how many mines are adjacent to this revealed square, and finally 'X' represents a revealed mine.

Now given the next click position (row and column indices) among all the unrevealed squares ('M' or 'E'), return the board after revealing this position according to the following rules:

If a mine ('M') is revealed, then the game is over - change it to 'X'.
If an empty square ('E') with no adjacent mines is revealed, then change it to revealed blank ('B') and all of its adjacent unrevealed squares should be revealed recursively.
If an empty square ('E') with at least one adjacent mine is revealed, then change it to a digit ('1' to '8') representing the number of adjacent mines.
Return the board when no more squares will be revealed.
 

Example 1:

Input: 

[['E', 'E', 'E', 'E', 'E'],
 ['E', 'E', 'M', 'E', 'E'],
 ['E', 'E', 'E', 'E', 'E'],
 ['E', 'E', 'E', 'E', 'E']]

Click : [3,0]

Output: 

[['B', '1', 'E', '1', 'B'],
 ['B', '1', 'M', '1', 'B'],
 ['B', '1', '1', '1', 'B'],
 ['B', 'B', 'B', 'B', 'B']]

Explanation:

Example 2:

Input: 

[['B', '1', 'E', '1', 'B'],
 ['B', '1', 'M', '1', 'B'],
 ['B', '1', '1', '1', 'B'],
 ['B', 'B', 'B', 'B', 'B']]

Click : [1,2]

Output: 

[['B', '1', 'E', '1', 'B'],
 ['B', '1', 'X', '1', 'B'],
 ['B', '1', '1', '1', 'B'],
 ['B', 'B', 'B', 'B', 'B']]

Explanation:

 

Note:

The range of the input matrix's height and width is [1,50].
The click position will only be an unrevealed square ('M' or 'E'), which also means the input board contains at least one clickable square.
The input board won't be a stage when game is over (some mines have been revealed).
For simplicity, not mentioned rules should be ignored in this problem. For example, you don't need to reveal all the unrevealed mines when the game is over, consider any cases that you will win the game or flag any squares.

class Solution {
    public char[][] updateBoard(char[][] borad, int[] c) {
        q(borad,0,0,true);
    }

    public void q(char[][] cc,int i,int j,boolean b){
        if(i<0||j<0||i==cc.length||j==cc[0].length){
        Breturn ;
        }
        
       
        if(cc[i][j]=='M'){
            if(b){
               cc[i][j]='X'; 
            }
            
            return;
        }
        if(cc[i][j]!='E')return ;

        int q = 0;
        if(i>0){
            if(cc[i-1][j]=='M'){
                q++;
                
            }
            if(j>0){
                if(cc[i-1][j-1]=='M'){
                    q++;
                }
            }

            if(j+1<cc[0].length){
                if(cc[i-1][j+1]=='M'){
                    q++;
                }
            }
        }

        if(i+1<cc.length){
            if(cc[i+1][j]=='M'){
                q++;
                
            }
            if(j>0){
                if(cc[i+1][j-1]=='M'){
                    q++;
                }
            }

            if(j+1<cc[0].length){
                if(cc[i+1][j+1]=='M'){
                    q++;
                }
            }
        }
        if(j>0){
             if(cc[i][j-1]=='M'){
                    q++;
                }
        }
        if(j+1<cc[0].length){
                if(cc[i][j+1]=='M'){
                    q++;
                }
            }

        if(q==0){
            cc[i][j]='B';
            q(cc,i-1,j,false);
            q(cc,i+1,j,false);
            q(cc,i,j-1,false);
            q(cc,i,j+1,false);
            q(cc,i-1,j+1,false);
            q(cc,i-1,j-1,false);
            q(cc,i+1,j+1,false);
            q(cc,i+1,j-1,false);
        }else{
            cc[i][j]=(char)(q+'0');
        }

    }
}

530. Minimum Absolute Difference in BST
Easy

632

52

Favorite

Share
Given a binary search tree with non-negative values, find the minimum absolute difference between values of any two nodes.

Example:

Input:

   1
    \
     3
    /
   2

Output:
1

Explanation:
The minimum absolute difference is 1, which is the difference between 2 and 1 (or between 2 and 3).

/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public int getMinimumDifference(TreeNode root) {
        return q(root,new TreeSet<>());    
    }

    public int q(TreeNode r,TreeSet<Integer> s){
        if(r==null)return Integer.MAX_VALUE;
        Integer i = Integer.MAX_VALUE;
        Integer q = s.lower(r.val);
        if(q==null){
            i=r.val-q;
        }
        Integer w = s.higher(r.val);
        if(w==null){
            i=Math.min(i,w-val);
        }
        s.add(r.val);
        int z = q(r.left,s);
        int x = q(r.right,s);
        return Math.min(i,Math.min(z,x));
    }

    class V{
        int i=-1;
    }
    public int getMinimumDifference(TreeNode root) {
        V q = new V();
        q.i=Integer.MAX_VALUE;
        return q(root,new V());    
    }

    public int q(TreeNode r,V v){
        Integer q = Integer.MAX_VALUE;
        if(r==null)return q;
        int z = q(r.left,v);
        if(v.i!=-1)q=r.val-v.i;
        v.i=r.val;
        return Math.min(q,Math.min(z,q(r.right,v)));
    }
}
[1,null,5,3]
class Solution {
public:
    int getMinimumDifference(TreeNode* root) {
        int res = INT_MAX, pre = -1;
        inorder(root, pre, res);
        return res;
    }
    void inorder(TreeNode* root, int& pre, int& res) {
        if (!root) return;
        inorder(root->left, pre, res);
        if (pre != -1) res = min(res, root->val - pre);
        pre = root->val;
        inorder(root->right, pre, res);
    }
};
class Solution {
public:
    int getMinimumDifference(TreeNode* root) {
        int res = INT_MAX;
        helper(root, INT_MIN, INT_MAX, res);
        return res;
    }
    void helper(TreeNode* root, int low, int high, int& res) {
        if (!root) return;
        if (low != INT_MIN) res = min(res, root->val - low);
        if (high != INT_MAX) res = min(res, high - root->val);
        helper(root->left, low, root->val, res);
        helper(root->right, root->val, high, res);
    }
};
